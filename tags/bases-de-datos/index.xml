<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Bases de Datos on AguasNegras</title>
    <link>https://www.aguasnegras.es/tags/bases-de-datos/</link>
    <description>Recent content in Bases de Datos on AguasNegras</description>
    <image>
      <url>https://www.aguasnegras.es/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://www.aguasnegras.es/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 07 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.aguasnegras.es/tags/bases-de-datos/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker y almacenamiento. Como cambiar el directorio de las imágenes y contenedores</title>
      <link>https://www.aguasnegras.es/posts/2019/03/07-docker_y_almacenamiento/</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.aguasnegras.es/posts/2019/03/07-docker_y_almacenamiento/</guid>
      <description>Los contenedores no solo tienen la ventaja de ser entornos aislados sino que además ocupan muy poco espacio en disco. Esto se debe a varias causas:
No tienen el sistema operativo al completo (como una máquina virtual) lo cual ya de por sí es un ahorro de espacio. El proceso de tener una imagen e ir &amp;ldquo;instanciando&amp;rdquo; contenedor no ocupa tanto como podríamos esperar (tamaño de imagen x contenedores) gracias a UnionFS, ya que solo se cambian los cambios de cada contenedor en particular.</description>
    </item>
    
    <item>
      <title>PostgreSQL en Docker</title>
      <link>https://www.aguasnegras.es/posts/2019/03/05-postgresql_y_docker/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.aguasnegras.es/posts/2019/03/05-postgresql_y_docker/</guid>
      <description>Una de las ventajas de Docker es que te aisla del problema de tener que instalar el software que necesitas para desarrollar. La encapsulación en contenedores no es solo una ventaja para los pasos a producción y la infraestructura como código sino que lo es, especialmente en entornos de desarrollo. En muchas ocasiones instalas una base de datos o una cola de mensajes y ajustando la configuración te la terminas cargando y tienes que volver a crearla.</description>
    </item>
    
    <item>
      <title>Java, PostgreSQL y Heroku</title>
      <link>https://www.aguasnegras.es/posts/2011/09/18-java-postgresql-y-heroku/</link>
      <pubDate>Sun, 18 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>https://www.aguasnegras.es/posts/2011/09/18-java-postgresql-y-heroku/</guid>
      <description>Ya he visto como desplegar en Heroku, pero lo que he desplegado no llega ni al nivel de aplicación web, en realidad es una página web estática y punto. Para poder considerarla aplicación web ha de tener algún tipo de contenido dinámico, normalmente este contenido se genera de algún almacén persistente, usualmente una base de datos. Por tanto voy a ver como me las apaño para poner una base de datos en Heroku y atacarla desde mi aplicación.</description>
    </item>
    
    <item>
      <title>Bases de Datos para Desarrolladores Java - Claves Primarias Artificiales</title>
      <link>https://www.aguasnegras.es/posts/2011/06/27-bases-de-datos-para-desarrolladores-java-claves-primarias-artificiales/</link>
      <pubDate>Mon, 27 Jun 2011 00:00:00 +0000</pubDate>
      
      <guid>https://www.aguasnegras.es/posts/2011/06/27-bases-de-datos-para-desarrolladores-java-claves-primarias-artificiales/</guid>
      <description>La teoría pura y dura de base de datos dice que para una entidad determinada, tendremos varias claves candidatas, que son aquellas que identifican únicamente a la entidad y la clave primaria se escoge de entre ellas como la menor. Para un usuario podemos tener como claves candidatas: DNI, nombre de usuario, nombre y apellidos. Nombre y apellidos se descarta (por larga) y ya tenemos que escoger entre DNI y nombre de usuario.</description>
    </item>
    
    <item>
      <title>Bases de Datos para Desarrolladores Java - Integridad Referencial</title>
      <link>https://www.aguasnegras.es/posts/2011/02/01-bases-de-datos-para-desarrolladores-java-integridad-referencial/</link>
      <pubDate>Tue, 01 Feb 2011 00:00:00 +0000</pubDate>
      
      <guid>https://www.aguasnegras.es/posts/2011/02/01-bases-de-datos-para-desarrolladores-java-integridad-referencial/</guid>
      <description>Como el entorno de desarrollo se ha caído y llevo dos horas aburrido, sigo.
Segundo Ítem: Usar siempre SIEMPRE la integridad referencial.
O lo que es lo mismo, si usamos MySQL NO usar MyIsam, ya que no tiene soporte para integridad referencial.
Hay gente que dice que trabajar sin integridad referencial es más rápido y cómodo. Es verdad, pero al final es como dispararse en el pie. Muchas veces la integridad referencial te salva de cometer errores de calado.</description>
    </item>
    
    <item>
      <title>Bases de Datos para Desarrolladores Java - Introducción e Índices</title>
      <link>https://www.aguasnegras.es/posts/2011/01/25-bases-de-datos-para-desarrolladores-java-introducci%C3%B3n-e-%C3%ADndices/</link>
      <pubDate>Tue, 25 Jan 2011 00:00:00 +0000</pubDate>
      
      <guid>https://www.aguasnegras.es/posts/2011/01/25-bases-de-datos-para-desarrolladores-java-introducci%C3%B3n-e-%C3%ADndices/</guid>
      <description>En general en una aplicación Java cualquiera los problemas empiezan desde abajo, con el diseño de la base de datos. He visto (y trabajo) con bases de datos en las que una tabla tiene 5 campos de primary key y uno solo de información. Que esto es un desperdicio se ve a simple vista. Después vienen los parches a nivel superior (en Java) y se termina yendo al infierno el rendimiento de la aplicación.</description>
    </item>
    
  </channel>
</rss>
