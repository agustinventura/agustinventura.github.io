<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <title>Wordpress to JBake - Parseo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AguasNegras, tecnología, programación y Java">
    <meta name="author" content="Agustín Ventura">
    <meta name="keywords" content="Programación, Java">
    <meta name="generator" content="JBake">
    <!-- Compiled and minified CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">

    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <link rel="stylesheet" href="../../../css/aguasnegras.css"/>
    <link rel="shortcut icon" href="../../../favicon.ico">
  </head>
  <body>
    <header>
<nav class="light-blue darken-3">
	<div class="container">
		<div class="nav-wrapper">
		      <a class="brand-logo" href="/"><span class="pageTitle">AguasNegras</span></a>
			    <ul id="nav-mobile" class="right hide-on-med-and-down">
			        <li><a href="../../../index.html">Inicio</a></li>
			        <li><a href="../../../about.html">Acerca De</a></li>
			        <li><a href="../../../feed.xml">Suscripci&oacute;n</a></li>
			    </ul>
		</div>
	</div>
</nav>
    </header>
<div class="container">
<div class="row">
<div class="col s12">
		<h4 class="light-blue-text text-darken-1">Wordpress to JBake - Parseo</h4>
		<div class="section">
			20 marzo 2016
		</div>
		<div class="section">
			<p>Pues ahora que ya tengo el constructor y construyo un objeto siempre que, al menos es coherente, toca parsear el xml para extraer los datos.<br />
En Java, esencialmente hay tres formas de parsear xml, todas dentro de lo que se denomina Java XML Processing API, <a href="https://docs.oracle.com/javase/tutorial/jaxp/index.html">JAXP</a>:</p>
<ol>
<li><a href="https://docs.oracle.com/javase/tutorial/jaxp/sax/index.html">SAX</a>: La API originaria, orientada a eventos. Muy rápida, muy eficiente y muy farragosa. Técnicamente es una API de streaming mediante push, es decir, nosotros arrancamos el procesamiento del documento y la API empieza a funcionar mandándonos eventos conforme va encontrando elementos.</li>
<li><a href="https://docs.oracle.com/javase/tutorial/jaxp/dom/index.html">DOM</a>: La API orientada a objetos, representa el XML como un árbol en memoria. Muy fácil de acceder, muy tragón de recursos. Técnicamente, se representa el árbol del DOM en memoria y listo, se puede acceder libremente, por ejemplo usando XPath.</li>
<li><a href="https://docs.oracle.com/javase/tutorial/jaxp/stax/index.html">StAX</a>: A partir del JDK 1.5 se encuentra disponible esta API que es un modelo mixto, se basa en un modelo de streaming (parecido a SAX) pero más sencillo de utilizar y además permite escribir. Técnicamente se define como una API de streming mediante pull, es decir, que somos nosotros los que vamos indicanto los elementos que queremos acceder. Eso sí, al ser de streaming solo permite avanzar en el documento, es decir, no podemos ignorar el elemento 1, tratar el 2 y en función de este retroceder a tratar el 1.</li>
</ol>
<p>En mi caso en particular, y dado que el modelo de &quot;ir hacia delante&quot; se adapta perfectamente al caso de uso (ya que simplemente estoy emparejando), pero tampoco necesito tantísima eficiencia ni tengo ganas de fastidiarme la vida, voy a utilizar StAX.</p>
<p>Pero lo primero, ahora que tengo que trabajar &quot;en serio&quot; es utilizar datos de verdad para las pruebas. Para eso hay dos opciones:</p>
<ol>
<li>Guardo un XML de pruebas en forma de un String en un archivo .java y lo leo de ahí.</li>
<li>Guardo un archivo XML como tal.</li>
</ol>
<p>Pues como que la primera opción es una tontería, he optado por la segunda. He sacado la exportación de datos que proporciona Wordpress y he dejado unos cuantos posts que sean más o menos representativos y listo. Lo guardo en <em>src/resources/wp-source.xml</em>. Antes de seguir, ya no tiene sentido que los tests sigan usando el <em>pom.xml</em> para las pruebas, así que lo cambio y lo lanzo. Todo en verde, como cabía esperar.</p>
<p>Ahora bien, ya tengo mi objeto de la clase Wp2JBake creado con el origen y el destino debidamente especificado, ¿como arranco el procesamiento? Hay que tener en cuenta que realmente el método de proceso no tiene por qué devolver nada, ya que el resultado efectivo de la salida es una estructura de archivos con el resultado de la conversión.<br />
Sin embargo, creo que es &quot;gratis&quot; devolver los elementos que se han generado y así se posibilita poder comprobar el resultado de la generación.</p>
<p>Así que primero el test:</p>
<pre><code class="language-prettyprint">@Test
public void processEmptyXML() {
    sut = new Wp2JBake(&quot;src/test/resources/empty.xml&quot;, &quot;src/test/destination&quot;);
    Set&lt;File&gt; markdowns = sut.generateJBakeMarkdown();
    assertThat(markdowns, is(empty()));
    File destination = new File(&quot;destination&quot;);
    destination.delete();
}
</code></pre>
<p>Obviamente, esta en rojo, allá va la implementación:</p>
<pre><code class="language-prettyprint">public Set&lt;File&gt; generateJBakeMarkdown() {
    return new HashSet&lt;File&gt;();
}
</code></pre>
<p>Y aquí, ya voy devolviendo un Set (porque todos los elementos serán distintos, cada archivo representa un post y cada post es único) y uso uno no ordenado, porque en realidad me dá igual el orden de iteración, ya que <a href="../02/04-wp2jbake.html">como decidí</a> los archivos vendrán ordenados por su ruta, es decir, si existen, por definición estan ordenados.</p>
<p>Vale, y ahora, test de verdad:</p>
<pre><code class="language-prettyprint">@Test
public void processXML() {
    sut = new Wp2JBake(&quot;src/test/resources/wp-source.xml&quot;, &quot;src/test/destination&quot;);
    Set&lt;File&gt; markdowns = sut.generateJBakeMarkdown();
    assertThat(markdowns, is(not(empty())));
    for (File markdown: markdowns) {
        assertThat(markdown.exists(), is(true));
    }
    File destination = new File(&quot;destination&quot;);
    destination.delete();
}
</code></pre>
<p>Ahora tengo que modificar el método <em>generateJBakeMarkdown</em> para que genere los archivos Markdown. En un principio hay dos formas de hacer ésto:</p>
<ol>
<li>Parseo el XML, genero una estructura de datos en memoria (una representación de los posts, vaya) y después la recorro y la paso a los archivos markdown. Desventaja, que para eso para qué demonios uso StAX y el streaming, si voy a comer memoria uso DOM y listo.</li>
<li>Parseo el XML y cada vez que se detecte un item (un post) lo voy escribiendo dinámicamente. Creo que esta opción es más complicada, pero más ligera.</li>
</ol>
<p>Vamos a por 2, para ello leeré el XML y lo volcaré... pero un momento, una cosa es saber leer el XML y otra escribir el Markdown, es decir, que mi clase lectora (<em>Wp2JBake</em>) a su vez debe comunicarse (usar) otra para escribir (<em>MdWriter</em>).<br />
Pensando un poco más sobre esta clase <em>MdWriter</em>... debería recibir como parámetro en su constructor el destino de las escrituras y eso me lleva a pensar, que realmente es a ella a la que le corresponde comprobar si es un destino legal, es decir, que el constructor de <em>Wp2JBake</em> ahora quedaría así (también he aprovechado y <em>origin</em> lo he guardado en un atributo de la clase):</p>
<pre><code class="language-prettyprint">public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
        throw new IllegalArgumentException(&quot;Origin is not a valid file&quot;);
    } else {
        this.origin = origin;
    }
    this.mdWriter = new MdWriter(destination);
}
</code></pre>
<p>Mientras que <em>MdWriter</em> sería así:</p>
<pre><code class="language-prettyprint">public class MdWriter {

    private File destinationFolder;

    public MdWriter(String destination) {
        if (StringUtils.isEmpty(destination) || !isWritable(destination)) {
            throw new IllegalArgumentException(&quot;Destination is not a valid folder&quot;);
        } else {
            destinationFolder = new File(destination);
        }
    }

    private boolean isWritable(String destination) {
        File destinationFolder = new File(destination);
        if (destinationFolder.exists()) {
            return destinationFolder.canWrite();
        } else {
            return isWritableDestinationParent(destinationFolder);
        }
    }

    private boolean isWritableDestinationParent(File destinationFolder) {
        File destinationParent = getDestinationParent(destinationFolder);
        return destinationParent.canWrite();
    }

    private File getDestinationParent(File destinationFolder) {
        String parentPath = destinationFolder.getParent();
        if (parentPath == null) {
            parentPath = &quot;&quot;;
        }
        return new File(parentPath);
    }
}
</code></pre>
<p>Por cierto que la teoría TDDista dice que esto no debería hacerse, que primero hay que pasar el test y después ponerse a refactorizar y tal... Hombre, yo eso no lo comparto tanto, creo que esta bien ir pensando un poco las cosas. Además, como ya tengo hechos los tests, los puedo volver a ejecutar para ver que no me he cargado nada.<br />
Que hablando de las pruebas, ahora tengo que crear las pruebas propias de esta nueva clase y llevarme todas las encargadas de testear la corrección del directorio destino a esa clase. Al separarlo además ya no tengo que diferenciar entre los tipos de excepción (era muy cantoso que estaba pasando del Single Responsability) y el código queda mucho más limpio:</p>
<pre><code class="language-prettyprint">public class Wp2JBakeTests {

    private Wp2JBake sut;

    @Test(expected = IllegalArgumentException.class)
    public void buildWithoutParameters() {
        sut = new Wp2JBake(null, null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithoutOrigin() {
        sut = new Wp2JBake(null, &quot;foo&quot;);

    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithEmptyOrigin() {
        sut = new Wp2JBake(&quot;&quot;, &quot;&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithInvalidOrigin() {
        sut = new Wp2JBake(&quot;foo&quot;, &quot;&quot;);
    }

    @Test
    public void buildWithValidParameters() {
        sut = new Wp2JBake(&quot;src/test/resources/wp-source.xml&quot;, &quot;src/test/destination&quot;);
    }

    @Test
    public void processEmptyXML() {
        sut = new Wp2JBake(&quot;src/test/resources/empty.xml&quot;, &quot;src/test/destination&quot;);
        Set&lt;File&gt; markdowns = sut.generateJBakeMarkdown();
        assertThat(markdowns, is(empty()));
    }

    @Test
    public void processXML() {
        sut = new Wp2JBake(&quot;src/test/resources/wp-source.xml&quot;, &quot;src/test/destination&quot;);
        Set&lt;File&gt; markdowns = sut.generateJBakeMarkdown();
        assertThat(markdowns, is(not(empty())));
        for (File markdown: markdowns) {
            assertThat(markdown.exists(), is(true));
        }
        File destination = new File(&quot;destination&quot;);
        destination.delete();
    }
}

public class MdWriterTest {

    private MdWriter sut;

    @Test(expected = IllegalArgumentException.class)
    public void writerWithoutDestination() {
        sut = new MdWriter(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithEmptyDestination() {
        sut = new MdWriter(&quot;&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestination() {
        File destination = new File(&quot;destination&quot;);
        destination.mkdir();
        destination.deleteOnExit();
        destination.setReadOnly();
        sut = new MdWriter(destination.getAbsolutePath());
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestinationParent() {
        File destinationParent = new File(&quot;destinationParent&quot;);
        destinationParent.mkdir();
        destinationParent.deleteOnExit();
        destinationParent.setReadOnly();
        sut = new MdWriter(destinationParent.getAbsolutePath() + File.separator + &quot;destination&quot;);
    }
}
</code></pre>
<p>Bueno, pues ahora tengo que leer el XML e ir cargando los Strings que el escritor se encargará de volcar a disco... muy bien. Lo primer es crear la factoría de eventos. Por cierto, menuda bazofia el tutorial oficial de Oracle, menos mal que <a href="http://www.vogella.com/tutorials/JavaXML/article.html">Lars Vogel</a>  tiene un grandísimo tutorial (danke schön Lars!):</p>
<pre><code class="language-prettyprint">public Set&lt;File&gt; generateJBakeMarkdown() {
        XMLEventReader eventReader = getEventReader();
        return new HashSet&lt;File&gt;();
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&quot;Could not find origin file: &quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&quot;Could not read origin file: &quot; + e.getMessage());
        }
        return eventReader;
    }
</code></pre>
<p>He optado por lanzar un IllegalStateException si ocurre alguna de las excepciones, ya que eso no debería ocurrir y a lo que lleva es exactamente a eso, un estado ilegal del programa :)<br />
Hmmm... por otra parte, tengo la prueba con el XML vacío, pero ahora que lo pienso ¡¡¡no tengo ninguna con un XML inválido!!! Me creo un XML <em>invalid.xml</em> que contiene solo la cabecera con un número de versión que no existe:</p>
<pre><code class="language-prettyprint">&lt;?xml version=&quot;-1.0&quot; encoding=&quot;utf-8&quot;?&gt;
</code></pre>
<p>Y su test:</p>
<pre><code class="language-prettyprint">@Test(expected = IllegalStateException.class)
public void processInvalidXML() {
    sut = new Wp2JBake(&quot;src/test/resources/invalid.xml&quot;, &quot;src/test/destination&quot;);
    Set&lt;File&gt; markdowns = sut.generateJBakeMarkdown();
}
</code></pre>
<p>Me esta empezando a parecer que la lectura también debería ir en otra clase y <em>Wp2JBake</em> tan solo orquestrar la lectura con la escritura... pero bueno, ya iremos viendo de momento sigo, así. Toca tratar los eventos. El tutorial hace un típico bucle while con el eventReader que implementa <em>Iterator</em>, pero claro, el tutorial es antiguo, al fin y al cabo y pensándolo bien... yo lo que quiero hacer es un filter y un collect, es decir, que puedo usar la API de Streams de Java 8. La única historia es convertir el <em>XMLEventReader</em> a un <em>Stream<XMLEvent></em>, pero eso es relativamente fácil:</p>
<pre><code class="language-prettyprint">public Set&lt;File&gt; generateJBakeMarkdown() {
    XMLEventReader eventReader = getEventReader();
    Iterable&lt;XMLEvent&gt; eventsIterable = () -&gt; eventReader;
    Stream&lt;XMLEvent&gt; xmlEvents = StreamSupport.stream(eventsIterable.spliterator(), false);
    return new HashSet&lt;File&gt;();
}
</code></pre>
<p>Bueno, pues después de echar hora y pico probando con filter, map, flatmap etc, hay un problema, y es que StAX entiende todo el documento secuencialmente, con lo cual no puedo hacer un filter y quedarme solo con los elemntos de tipo <em>item</em> y después acceder a los elementos que contienen estos, porque un elemento esta suelto, así que nada, toca iteradores y bucles for de toda la vida. Para que sea más entendible (y orientado a objetos), me voy a crear una clase <em>Post</em> para ir guardando los resultados y después volcarlos al archivo pertinente.<br />
Esta clase la monto con una API fluida para que la construcción me sea más sencilla y los correspondientes getters:</p>
<pre><code class="language-prettyprint">public class Post {
    private String title;

    private LocalDate publishingDate;

    private Set&lt;String&gt; tags = new TreeSet&lt;&gt;();

    private String content;

    public Post () {

    }

    public Post withTitle(String title) {
        this.title = title;
        return this;
    }

    public Post withPublishingDate(LocalDate publishingDate) {
        this.publishingDate = publishingDate;
        return this;
    }

    public Post withTag(String tag) {
        this.tags.add(tag);
        return this;
    }

    public Post withContent(String content) {
        this.content = content;
        return this;
    }

    public String getTitle() {
        return title;
    }

    public LocalDate getPublishingDate() {
        return publishingDate;
    }

    public Set&lt;String&gt; getTags() {
        return tags;
    }

    public String getContent() {
        return content;
    }
}
</code></pre>
<p>En fín, ya han pasado como tres horas y el test sigue sin funcionar... me deprimo...<br />
Sigo con el for, la estrategia es muy sencilla, si detecto un elemento <em>item</em>, creo un nuevo <em>Post</em> y conforme vaya detectando los elementos <em>title</em>, <em>pubDate</em>, <em>category</em> y <em>content</em> voy invocando a los métodos <em>with*</em> del <em>Post</em>. En el momento que detecte el cierre del <em>item</em>, escribo a disco:</p>
<pre><code class="language-prettyprint">public Set&lt;File&gt; generateJBakeMarkdown() {
    XMLEventReader eventReader = getEventReader();
    Iterable&lt;XMLEvent&gt; eventsIterable = () -&gt; eventReader;
    Stream&lt;XMLEvent&gt; xmlEvents = StreamSupport.stream(eventsIterable.spliterator(), false);
    return new HashSet&lt;File&gt;();
}
</code></pre>
<p>Desafortunadamente, el tema es más complejo de lo que parecía. Dado que StAX solo lee en un sentido (palante), de poco me sirve la API de streams de Java 8, ya que tengo que ir tomando decisiones en función del elemento que llegue, por ejemplo, un elemento <em>title</em> se debe ignorar salvo que previamente se haya recibido un <em>item</em>.<br />
No digo que no sea posible hacerlo con streams, solo que después de muchos relíos es más sencillo hacerlo con dos while:</p>
<ol>
<li>El primer while que itera sobre todos los elementos proporcionados por StAX.</li>
<li>El segundo while empieza cuando se detecta un <em>item</em> y termina cuando se cierra el <em>item</em>, leyendo por tanto un post completo.</li>
</ol>
<p>Con esto en mente es bastante fácil:</p>
<pre><code class="language-prettyprint">public Set&lt;File&gt; generateJBakeMarkdown() {
        HashSet&lt;File&gt; exportResult = new HashSet&lt;&gt;();
        XMLEventReader eventReader = getEventReader();
        try {
            exportPosts(exportResult, eventReader);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&quot;Error reading XML &quot; + origin + &quot;: &quot; + e.getMessage());
        }
        return exportResult;
    }

    private void exportPosts(HashSet&lt;File&gt; exportResult, XMLEventReader eventReader) throws XMLStreamException {
        Post post = null;
        while (eventReader.hasNext()) {
                XMLEvent event = eventReader.nextEvent();
                if (isPostStart(event)) {
                    post = exportPost(exportResult, eventReader, post);
                }
        }
    }

    private Post exportPost(HashSet&lt;File&gt; exportResult, XMLEventReader eventReader, Post post) throws XMLStreamException {
        if (post != null) {
            exportResult.add(mdWriter.write(post));
        }
        post = readPost(eventReader);
        return post;
    }

    private Post readPost(XMLEventReader eventReader) throws XMLStreamException {
        Post exportedPost = new Post();
        boolean postRead = false;
            while (!postRead &amp;&amp; eventReader.hasNext()) {
                XMLEvent event = eventReader.nextEvent();
                if (event.isStartElement()) {
                    exportedPost = loadPostFromEvent(event, eventReader, exportedPost);
                } else if (isPostEnd(event)) {
                    postRead = true;
                }
            }
        return exportedPost;
    }

    private boolean isPostEnd(XMLEvent event) {
        return event.isEndElement() &amp;&amp; &quot;item&quot;.equals(event.asEndElement().getName().getPrefix() + event.asEndElement().getName().getLocalPart());
    }

    private boolean isPostStart(XMLEvent event) {
        return event.isStartElement() &amp;&amp; &quot;item&quot;.equals(getEventFullName(event));
    }

    private Post loadPostFromEvent(XMLEvent event, XMLEventReader eventReader, Post post) {
        String name = getEventFullName(event);
        try {
            switch (name) {
                case &quot;title&quot;:
                    post = loadTitle(eventReader, post);
                    break;
                case &quot;pubDate&quot;:
                    post = loadPublishingDate(eventReader, post);
                    break;
                case &quot;category&quot;:
                    if (isTag(event)) {
                        post = loadCategory(eventReader, event, post);
                    }
                    break;
                case &quot;contentencoded&quot;:
                    post = loadContent(eventReader, post);
                    break;
                default:
                    break;
            }
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&quot;Error parsing &quot; + name + &quot;: &quot; + e.getMessage());
        }
        return post;
    }

    private Post loadContent(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withContent(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadCategory(XMLEventReader eventReader, XMLEvent event, Post post) throws XMLStreamException {
            return post.withTag(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadPublishingDate(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withPublishingDate(parsePubDate(eventReader));
    }

    private Post loadTitle(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withTitle(eventReader.nextEvent().asCharacters().getData());
    }

    private String getEventFullName(XMLEvent event) {
        return event.asStartElement().getName().getPrefix() + event.asStartElement().getName().getLocalPart();
    }

    private boolean isTag(XMLEvent event) {
        return &quot;post_tag&quot;.equals(event.asStartElement().getAttributeByName(new QName(&quot;domain&quot;)).getValue());
    }


    private Date parsePubDate(XMLEventReader eventReader) throws XMLStreamException {
        Date publishingDate = null;
        try {
            String pubDate = eventReader.nextEvent().asCharacters().getData();
            pubDate = extractDate(pubDate);
            SimpleDateFormat format = new SimpleDateFormat(&quot;dd MMM yyyy&quot;);
            publishingDate = format.parse(pubDate);
        } catch (ParseException e) {
            throw new IllegalStateException(&quot;Could not parse pubDate: &quot; + e.getMessage());
        }
        return publishingDate;
    }

    private String extractDate(String pubDate) {
        //Date is supplied as this: Wed, 30 Nov -0001 00:00:00 +0000, we need to extract just the date
        pubDate = pubDate.substring(pubDate.indexOf(&quot;,&quot;)+2);
        int hourIndex = pubDate.indexOf(&quot;:&quot;)-3;
        pubDate = pubDate.substring(0, hourIndex);
        return pubDate;
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&quot;Could not find origin file: &quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&quot;Could not read origin file: &quot; + e.getMessage());
        }
        return eventReader;
    }

    private boolean existsOrigin(String origin) {
        File originFile = new File(origin);
        String path = originFile.getAbsolutePath();
        return originFile.exists();
    }
</code></pre>
<p>Lo del parseo de la fecha ha sido un espectáculo... no he sido capaz de sacarlo con el DateFormatter para convertirlo a un LocalDate.<br />
Bueno, pues ahora que lo tengo... ¿no tendría más sentido que todo eso fuera a una clase propia? Digamos WpReader. Pues sí, porque ahora mismo mi clase principal se esta responsabilizando de saber como se leen los posts y qué hacer con los posts leidos, así que es mucho más claro hacerlo con una colaboradora.<br />
Pero claro, si me llevo la lógica aparte, ¿cómo aviso de que se puede escribir un nuevo post sin romper el while que itera sobre todos los elementos del XML?<br />
Bueno, pues finamente diría que voy a usar un patrón observador, para notificar de cuando hay un nuevo post. Técnicamente lo que voy a hacer es implementar un callback y así <em>Wp2JBake</em> queda mucho más clara:</p>
<pre><code class="language-prettyprint">public class Wp2JBake {

    private WpReader wpReader;

    private MdWriter mdWriter;

    private HashSet&lt;File&gt; exportResult;

    public Wp2JBake(String origin, String destination) {
        this.wpReader = new WpReader(origin);
        this.mdWriter = new MdWriter(destination);
    }

    public Set&lt;File&gt; generateJBakeMarkdown() {
        exportResult = new HashSet&lt;&gt;();
        wpReader.readPosts(this);
        return exportResult;
    }

    public void postRead(Post post) {
        exportResult.add(mdWriter.write(post));
    }
}
</code></pre>
<p>Y por otro lado tenemos <em>WpReader</em>:</p>
<pre><code class="language-prettyprint">public class WpReader {

    public static final String ITEM = &quot;item&quot;;
    public static final String TITLE = &quot;title&quot;;
    public static final String PUB_DATE = &quot;pubDate&quot;;
    public static final String CATEGORY = &quot;category&quot;;
    public static final String CONTENT = &quot;contentencoded&quot;;
    public static final String POST_TAG = &quot;post_tag&quot;;
    public static final String DOMAIN = &quot;domain&quot;;
    private String origin;

    public WpReader(String origin) {
        if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
            throw new IllegalArgumentException(&quot;Origin is not a valid file&quot;);
        } else {
            this.origin = origin;
        }
    }

    private boolean existsOrigin(String origin) {
        File originFile = new File(origin);
        return originFile.exists();
    }

    public void readPosts(Wp2JBake wp2JBake) {
        XMLEventReader eventReader = getEventReader();
        try {
            readXML(wp2JBake, eventReader);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&quot;Error reading XML &quot; + origin + &quot;: &quot; + e.getMessage());
        }
    }

    private void readXML(Wp2JBake wp2JBake, XMLEventReader eventReader) throws XMLStreamException {
        while (eventReader.hasNext()) {
            readElement(wp2JBake, eventReader);
        }
    }

    private void readElement(Wp2JBake wp2JBake, XMLEventReader eventReader) throws XMLStreamException {
        XMLEvent event = eventReader.nextEvent();
        if (isPostStart(event)) {
            Post post = readPost(eventReader);
            wp2JBake.postRead(post);
        }
    }

    private Post readPost(XMLEventReader eventReader) throws XMLStreamException {
        Post exportedPost = new Post();
        boolean postRead = false;
        while (!postRead &amp;&amp; eventReader.hasNext()) {
            XMLEvent event = eventReader.nextEvent();
            if (event.isStartElement()) {
                exportedPost = loadAttribute(event, eventReader, exportedPost);
            } else if (isPostEnd(event)) {
                postRead = true;
            }
        }
        return exportedPost;
    }

    private boolean isPostEnd(XMLEvent event) {
        return event.isEndElement() &amp;&amp; ITEM.equals(event.asEndElement().getName().getPrefix() + event.asEndElement().getName().getLocalPart());
    }

    private Post loadAttribute(XMLEvent event, XMLEventReader eventReader, Post post) {
        String name = getEventFullName(event);
        try {
            post = loadAttribute(event, eventReader, post, name);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&quot;Error parsing &quot; + name + &quot;: &quot; + e.getMessage());
        }
        return post;
    }

    private Post loadAttribute(XMLEvent event, XMLEventReader eventReader, Post post, String name) throws XMLStreamException {
        switch (name) {
            case TITLE:
                post = loadTitle(eventReader, post);
                break;
            case PUB_DATE:
                post = loadPublishingDate(eventReader, post);
                break;
            case CATEGORY:
                if (isTag(event)) {
                    post = loadCategory(eventReader, post);
                }
                break;
            case CONTENT:
                post = loadContent(eventReader, post);
                break;
            default:
                break;
        }
        return post;
    }

    private Post loadContent(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withContent(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadCategory(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withTag(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadPublishingDate(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withPublishingDate(parsePubDate(eventReader));
    }

    private Post loadTitle(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withTitle(eventReader.nextEvent().asCharacters().getData());
    }

    private boolean isTag(XMLEvent event) {
        return POST_TAG.equals(event.asStartElement().getAttributeByName(new QName(DOMAIN)).getValue());
    }


    private Date parsePubDate(XMLEventReader eventReader) throws XMLStreamException {
        Date publishingDate = null;
        try {
            String pubDate = eventReader.nextEvent().asCharacters().getData();
            pubDate = extractDate(pubDate);
            SimpleDateFormat format = new SimpleDateFormat(&quot;dd MMM yyyy&quot;);
            publishingDate = format.parse(pubDate);
        } catch (ParseException e) {
            throw new IllegalStateException(&quot;Could not parse pubDate: &quot; + e.getMessage());
        }
        return publishingDate;
    }

    private String extractDate(String pubDate) {
        //Date is supplied as this: Wed, 30 Nov -0001 00:00:00 +0000 (RFC822 presumably), we need to extract just the date
        pubDate = pubDate.substring(pubDate.indexOf(&quot;,&quot;)+2);
        int hourIndex = pubDate.indexOf(&quot;:&quot;)-3;
        pubDate = pubDate.substring(0, hourIndex);
        return pubDate;
    }

    private boolean isPostStart(XMLEvent event) {
        return event.isStartElement() &amp;&amp; ITEM.equals(getEventFullName(event));
    }

    private String getEventFullName(XMLEvent event) {
        return event.asStartElement().getName().getPrefix() + event.asStartElement().getName().getLocalPart();
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&quot;Could not find origin file: &quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&quot;Could not read origin file: &quot; + e.getMessage());
        }
        return eventReader;
    }
}
</code></pre>
<p>Pues para terminar con esta sección que se ha alargado más de lo que esperaba, me queda modificar los tests:</p>
<pre><code class="language-prettyprint">@RunWith(MockitoJUnitRunner.class)
public class WpReaderTest {

    private WpReader sut;

    @Mock
    private Wp2JBake observer;

    @Test(expected = IllegalArgumentException.class)
    public void readerWithoutOrigin() {
        sut = new WpReader(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void readerWithEmptyOrigin() {
        sut = new WpReader(&quot;&quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithInvalidOrigin() {
        sut = new WpReader(&quot;foo&quot;);
    }

    @Test(expected = IllegalStateException.class)
    public void readEmptyXML() {
        sut = new WpReader(&quot;src/test/resources/empty.xml&quot;);
        sut.readPosts(observer);
    }

    @Test(expected = IllegalStateException.class)
    public void readInvalidXML() {
        sut = new WpReader(&quot;src/test/resources/invalid.xml&quot;);
        sut.readPosts(observer);
    }

    @Test
    public void readValidXML() {
        sut = new WpReader(&quot;src/test/resources/wp-source.xml&quot;);
        ArgumentCaptor&lt;Post&gt; postCapturer = ArgumentCaptor.forClass(Post.class);
        sut.readPosts(observer);
        verify(observer, times(7)).postRead(postCapturer.capture());
    }
}
</code></pre>
<p>Con esto ya ha quedado perfecto, si no tanto el software, si los tests. Cada clase tiene una responsabilidad bien definida y así se refleja en los tests. Eso sí, en esta última clase he tenido que meter Mockito para simular el <em>Wp2JBake</em> que me hace falta para el callback. Lo bueno de esto es que con Mockito puedo verificar las llamadas a los métodos y por primera vez tengo todos los tests en verde.<br />
Eso sí, los tests de <em>Wp2JBake</em> se han quedado en realidad como pruebas de integración, así que no me preocupa que el test original siga en rojo porque realmente hasta que no este implementada la escritura no debería pasar a verde :).</p>

		</div>
<div class="col s12">
<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
        this.page.url = 'http://www.aguasnegras.es/blog/2016/03/20-wp2jbake-parseo.html';
        this.page.identifier = 'blog/2016/03/20-wp2jbake-parseo.html';
    };
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//aguasnegras.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
</div>
</div>
</div>
    <footer class="page-footer light-blue darken-3">
      <div class="container">
        <div class="row">
         <div class="col s5">
			<h5><a href="../../../archive.html" class="white-text">Archivo</a></h5>
			<p><a href="../../../archive.html" class="white-text">Todos los posts</a></p>
	    </div>
	    <div class="col s5">
            <h5 class="white-text">Tags</h5>
			    <a href="../../../tags/DDD.html"><div class="chip">DDD</div></a>
			    <a href="../../../tags/Eclipse.html"><div class="chip">Eclipse</div></a>
			    <a href="../../../tags/GitHub.html"><div class="chip">GitHub</div></a>
			    <a href="../../../tags/PostgreSQL.html"><div class="chip">PostgreSQL</div></a>
			    <a href="../../../tags/Time.html"><div class="chip">Time</div></a>
			    <a href="../../../tags/SVQJUG.html"><div class="chip">SVQJUG</div></a>
			    <a href="../../../tags/Minientrada.html"><div class="chip">Minientrada</div></a>
			    <a href="../../../tags/WordPress.html"><div class="chip">WordPress</div></a>
			    <a href="../../../tags/Docker.html"><div class="chip">Docker</div></a>
			    <a href="../../../tags/JUnit.html"><div class="chip">JUnit</div></a>
			    <a href="../../../tags/JavaScript.html"><div class="chip">JavaScript</div></a>
			    <a href="../../../tags/Proyectos.html"><div class="chip">Proyectos</div></a>
			    <a href="../../../tags/tutorial.html"><div class="chip">tutorial</div></a>
			    <a href="../../../tags/Spring Roo.html"><div class="chip">Spring Roo</div></a>
			    <a href="../../../tags/Emulador.html"><div class="chip">Emulador</div></a>
			    <a href="../../../tags/Markdown.html"><div class="chip">Markdown</div></a>
			    <a href="../../../tags/log4j.html"><div class="chip">log4j</div></a>
			    <a href="../../../tags/Logging.html"><div class="chip">Logging</div></a>
			    <a href="../../../tags/Java.html"><div class="chip">Java</div></a>
			    <a href="../../../tags/Hibernate.html"><div class="chip">Hibernate</div></a>
			    <a href="../../../tags/slf4j.html"><div class="chip">slf4j</div></a>
			    <a href="../../../tags/Heroku.html"><div class="chip">Heroku</div></a>
			    <a href="../../../tags/Base de Datos.html"><div class="chip">Base de Datos</div></a>
			    <a href="../../../tags/Problemas.html"><div class="chip">Problemas</div></a>
			    <a href="../../../tags/Spring.html"><div class="chip">Spring</div></a>
			    <a href="../../../tags/Date.html"><div class="chip">Date</div></a>
			    <a href="../../../tags/Android.html"><div class="chip">Android</div></a>
			    <a href="../../../tags/SQL.html"><div class="chip">SQL</div></a>
			    <a href="../../../tags/JBake.html"><div class="chip">JBake</div></a>
			    <a href="../../../tags/Ruby on Rails.html"><div class="chip">Ruby on Rails</div></a>
			    <a href="../../../tags/Git.html"><div class="chip">Git</div></a>
			    <a href="../../../tags/Linux.html"><div class="chip">Linux</div></a>
			    <a href="../../../tags/JustPlay.html"><div class="chip">JustPlay</div></a>
			    <a href="../../../tags/Cloud.html"><div class="chip">Cloud</div></a>
			    <a href="../../../tags/Wordpress.html"><div class="chip">Wordpress</div></a>
			    <a href="../../../tags/logging.html"><div class="chip">logging</div></a>
			    <a href="../../../tags/Programación.html"><div class="chip">Programación</div></a>
			    <a href="../../../tags/Tools of the Trade.html"><div class="chip">Tools of the Trade</div></a>
			    <a href="../../../tags/Amazon.html"><div class="chip">Amazon</div></a>
			    <a href="../../../tags/SEO.html"><div class="chip">SEO</div></a>
			    <a href="../../../tags/Intellij IDEA.html"><div class="chip">Intellij IDEA</div></a>
			    <a href="../../../tags/Tizen.html"><div class="chip">Tizen</div></a>
	    </div>
        <div class="col s2 right-align">
            <a href="http://twitter.com/agustinventura" target="_blank" class="social-link white-text" ><i class="fa  fa-twitter  fa-3x" title="Twitter" aria-hidden="true"></i></a>
            <a href="http://github.com/agustinventura" target="_blank" class="social-link white-text"><i class="fa  fa-github  fa-3x" title="Github" aria-hidden="true"></i></a>
            <a href="https://www.linkedin.com/in/agustinventura" target="_blank" class="social-link white-text"><i class="fa  fa-linkedin  fa-3x" title="LinkedIn" aria-hidden="true"></i></a>
        </div>
      </div>
      </div>
      </div>
      <div class="footer-copyright">
            <div class="container">
        <p class="center-align">&copy; 2016 | Mixed with <a class="footer-link white-text" href="http://materializecss.com/" target="_blank">Materialize</a> | Baked with <a <a class="footer-link white-text" href="http://jbake.org">JBake</a></p>
            </div>
          </div>
    </footer>

    <script async src="//cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
		<script async src="//code.jquery.com/jquery-2.1.4.min.js"></script>
    <script async src="//cdnjs.cloudflare.com/ajax/libs/materialize/0.97.5/js/materialize.min.js"></script>
  </body>
</html>
