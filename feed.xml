<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AguasNegras</title>
    <link>http://www.aguasnegras.es</link>
    <atom:link href="http://www.aguasnegras.es/feed.xml" rel="self" type="application/rss+xml" />
    <description>AguasNegras, tecnología, programación y Java</description>
    <language>es-es</language>
    <pubDate>jue, 9 jun 2016 21:35:56 +0200</pubDate>
    <lastBuildDate>jue, 9 jun 2016 21:35:56 +0200</lastBuildDate>

    <item>
      <title>Configuración de Linux Mint</title>
      <link>http://www.aguasnegras.es/blog/2016/06/09-configuracion-mint.html</link>
      <pubDate>jue, 9 jun 2016 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2016/06/09-configuracion-mint.html</guid>
      	<description>
	&lt;p&gt;Aprovechando que he actualizado el portátil (le he puesto 16 Gb de RAM y un SSD de 240 Gb), voy a documentar un poco mi configuración para que no se me vuelva a olvidar.&lt;br/&gt;En primer lugar he instalado el último Linux Mint disponible, el 17.3 Rosa. No soy un gran fan de Mint (de hecho me parece que gráficamente hablando se han quedado un poco desfasados).&lt;br/&gt;Una vez instalado he dado los siguientes pasos:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Actualizar el sistema: apt-get update &amp;amp;&amp;amp; apt-get upgrade&lt;/li&gt;
  &lt;li&gt;Instalar los últimos drivers de nvidia a través del mismo Administrador de controladores de Mint. Con eso y reiniciando ya me encuentra el HDMI (cosas de tener una tarjeta gráfica dual) y por tanto puedo usar el monitor de 23&quot;.&lt;/li&gt;
  &lt;li&gt;Instalar los drivers del adaptador wifi usb. El adaptador wifi de mi portátil deja bastante que desear, así que habitualmente uso un d-link usb para el wifi. La cosa es que el driver que trae por defecto Ubuntu (y Mint por extensión) es bastante malo (MUY malo), pero afortunadamente la comunidad se ha currado un driver mejor, &lt;a href=&quot;https://github.com/pvaret/rtl8192cu-fixes&quot;&gt;éste&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Instalar vim.&lt;/li&gt;
  &lt;li&gt;Desactivar la gestión de energía del wifi usb (wlan1) para que siempre vaya al máximo. Consume más, pero la verdad, la batería del portátil ya es vieja y dura media hora, así que me dá igual xD. En fín, me creo un script que lo desactivará en cada inicio: sudo vi sudo touch /etc/pm/power.d/wireless. Y ahí pongo las siguientes dos líneas:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;#!/bin/sh
/sbin/iwconfig wlan0 power off
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por último, le cambio los permisos a 755: sudo chmod 755 /etc/pm/power.d/wireless y listo.&lt;br/&gt;6. Deshabilitar la tarjeta wifi por defecto: añado iface wlan0 inet manual a /etc/network/interfaces&lt;br/&gt;7. En Configuración del Sistema &amp;gt; Apariencia &amp;gt; Efectos, desactivar&lt;br/&gt;8. En Configuración del Sistema &amp;gt; Preferencias &amp;gt; Ajuste de ventanas, desactivar&lt;br/&gt;9. En Configuración del Sistema &amp;gt; Preferencias &amp;gt; Escritorio, desactivar mostrar iconos de escritorio&lt;br/&gt;10. Instalar Chrome&lt;br/&gt;11. Instalar Atom&lt;br/&gt;12. Instalar terminator&lt;br/&gt;13. Instalar Java. Seamos sinceros, el OpenJDK por no hablar del IceTea son reguleros, así que instalo el Java oficial de Oracle usando el PPA de &lt;a href=&quot;http://www.webupd8.org/2012/09/install-oracle-java-8-in-ubuntu-via-ppa.html&quot;&gt;Webupd8&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Y ahora vamos con una lista de consejos sacados de &lt;a href=&quot;https://sites.google.com/site/easylinuxtipsproject&quot;&gt;Easy Linux Tips&lt;/a&gt; y aplicados según mi buen criterio:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Disminuir lo proclive que es el sistema a usar la SWAP, sobre todo ahora que tengo 16 Gb de RAM. El swappiness es un parámetro del 0 al 100, así que lo voy a dejar en 5. Para eso edito el archivo /etc/sysctl.conf y al final pongo el parámetro vm.swappiness=5&lt;/li&gt;
  &lt;li&gt;Otra opción a tunear ahí es el uso de la caché. El procesador usa una caché de datos y otra de inodes (información del sistema de ficheros). Habitualmente tiene prioridad total la de datos, pero en equipos de escritorio se &lt;a href=&quot;http://bicosyes.com/2007/10/mejorando-rendimiento-en-linux-de-escritorio/&quot;&gt;recomienda&lt;/a&gt; ponerlo al 50. Para eso se usa el parámetro vm.vfs_cache_pressure=50 en /etc/sysctl.conf.&lt;/li&gt;
  &lt;li&gt;Desactivar la hibernación. Bueno, lo de hibernar los equipos me parece una soberana gilipollez (así de claro), así que lo desactivo ejecutando ésto: sudo mv -v /etc/polkit-1/localauthority/50-local.d/com.ubuntu.enable-hibernate.pkla / sencillamente muevo el archivo de configuración a root, así ya no lo encuentra y listo&lt;/li&gt;
  &lt;li&gt;Ahora vamos con el tuneo específico para el SSD, que es la primera vez que lo hago. En primer lugar, le añado noatime en /etc/fstab a las dos particiones ext4 que tengo (/ y /home), de esta manera, no se escribirá la hora de acceso a los ficheros en el disco y me ahorro escrituras (que son satán para los SSD). Los vuelvo a montar con sudo mount -a&lt;/li&gt;
  &lt;li&gt;TRIM es un comando que sirve para optimizar el uso y acceso de la SSD y en general mantener la velocidad. Bueno, pues por lo visto en Ubuntu y Mint se ejecuta a través de un cron semanal (bieeeeennn old school total). Lo voy a pasar a rc.local para que se ejecute en cada arranque y listo. Edito /etc/rc.local y añado dos líneas: fstrim / y fstrim /home antes del exit 0. Por último, desactivo el cron, sencillamente muevo el script de sitio: sudo mv -v /etc/cron.weekly/fstrim /fstrim&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Ahora unos trucos para acelerar el arranque:&lt;br/&gt;1. Deshabilitar la splash screen, a mí de todas formas no me gusta, prefiero ver el proceso de arranque. Edito la configuración de grub en /etc/default/grub y la línea GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot; la cambio por GRUB_CMDLINE_LINUX_DEFAULT=&quot;profile&quot;. De esa manera puedo controlar el proceso de arranque y además me hace un profiling para acelerarlo un poco.&lt;br/&gt;2. Instalo bum (bootup manager) y desactivo varios servicios que vienen activos y que no uso: openvpn, virtualbox-guest-utils y saned.&lt;/p&gt;&lt;p&gt;Y por último, las chorradas:&lt;br/&gt;1. Instalar grub-customizer para poner bonito el grub sin tener que usar la línea de comando. Ponerle una imagen, etc...&lt;br/&gt;2. Instalar el conky y ajustar el .conkyrc&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Wordpress to JBake - Integración</title>
      <link>http://www.aguasnegras.es/blog/2016/06/08-wp2jbake-integracion.html</link>
      <pubDate>mié, 8 jun 2016 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2016/06/08-wp2jbake-integracion.html</guid>
      	<description>
	&lt;p&gt;Realmente las pruebas de integración ya casi estan hechas y son muy sencillas ya que se trata de interactuar en todo caso con la clase principal &lt;em&gt;Wp2JBake&lt;/em&gt;, usando donde sea necesario el archivo de pruebas.&lt;br/&gt;Lo único interesante van a ser los asserts para comprobar que todo es correcto.&lt;br/&gt;En un principio, las pruebas definidas pasan sin mayor problema, pero en primer lugar, hay que preguntarse si se estan exportando todos los posts o solo aquellos que estan publicados, es decir, el test usando el wp-source.xml sería el siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;@Test
public void processXML() {
    sut = new Wp2JBake(POSTS_SOURCE, DESTINATION);
    Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
    assertThat(markdowns.size(), is(5));
    assertThat(markdowns, is(not(empty())));
    for (File markdown: markdowns) {
        assertThat(markdown.exists(), is(true));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y este test falla porque markdowns tiene 7 elementos. Esto es así porque hay 2 elementos que en &lt;em&gt;pubDate&lt;/em&gt; tienen como año el -0001, lo cual significa que es un borrador, así que hay que corregir la implementación. En un principio lo iba a poner en el &lt;em&gt;MdWriter&lt;/em&gt;, pero realmente esta clase tan solo tiene que conocer los detalles de la escritura, no cuales elementos se deben escribir y cuales no. En &lt;em&gt;WpParser&lt;/em&gt; tampoco tiene sentido por motivos similares, esta clase solo lee. Pensándolo de otra forma, ¿qué clase es la que decide cómo se lee y cómo se escribe? Pues &lt;em&gt;Wp2JBake&lt;/em&gt;, más concretamente en el callback &lt;em&gt;postRead&lt;/em&gt;, así que ahí es el sitio en el que decidir si el post se exporta o no:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;public class Wp2JBake {

    public static final int DRAFT_YEAR = 2;
    private WpReader wpReader;

    private MdWriter mdWriter;

    private HashSet&amp;lt;File&amp;gt; exportResult;

    public Wp2JBake(String origin, String destination) {
        this.wpReader = new WpReader(origin);
        this.mdWriter = new MdWriter(destination);
    }

    public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
        exportResult = new HashSet&amp;lt;&amp;gt;();
        wpReader.readPosts(this);
        return exportResult;
    }

    public void postRead(Post post) {
        if (!postIsDraft(post)) {
            exportResult.add(mdWriter.write(post));
        }
    }

    private boolean postIsDraft(Post post) {
        Calendar postCalendar = Calendar.getInstance();
        postCalendar.setTime(post.getPublishingDate());
        return (postCalendar.get(Calendar.YEAR) == DRAFT_YEAR);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lo de la fecha es un poco... por algún motivo, al hacer el parseo de la fecha, decide que el año -0001 lo va a convertir en 2, eah... pues nada, así se queda porque tanto me dá un valor como otro. Y ahora ya pasa el test. Bueno, pues lo siguiente es comprobar qué pasa con las etiquetas &lt;code&gt;&amp;lt;pre&lt;/code&gt;&amp;gt;.&lt;br/&gt;El problema que hay realmente con esas etiquetas no es del conversor ni nada, sino que al migrar a JBake tengo que pasarlas a prettyprint para que las entienda, puedo tener el mismo problema con otras etiquetas, que las tenga que convertir por un motivo de formato, que no queden muy feas en el nuevo diseño del blog.&lt;br/&gt;Pero empiezo por las &lt;code&gt;&amp;lt;pre&lt;/code&gt;&amp;gt;. Esto sí que es claramente algo a tratar en &lt;em&gt;MdWriter&lt;/em&gt;, el plugin de Wordpress para colorear el código utilizaba distintas marcas como &lt;code&gt;&amp;lt;pre lang=xml&lt;/code&gt;&amp;gt; o &lt;code&gt;&amp;lt;pre lang=java&lt;/code&gt;&amp;gt; por tanto hay que sustituir en content todo lo que sea &lt;code&gt;&amp;lt;pre *&lt;/code&gt;&amp;gt; por `````prettyprint linenums. Ahora que lo pienso, &lt;em&gt;MdWriter&lt;/em&gt; debe saber como escribir, pero desde luego no es responsabilidad suya saber como traducir, así que sale una clase nueva &lt;em&gt;MdTranslator&lt;/em&gt; con un único método, &lt;em&gt;translate&lt;/em&gt;. Y repasando el método de escritura del post, también es responsabilidad suya el convertir los tags y la fecha, ahora se ve claramente, así que harán falta más métodos.&lt;/p&gt;&lt;p&gt;Habrá que crear sus correspondientes test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;public class MdTranslatorTest {

    public static final String TAG_1 = &amp;quot;tag 1&amp;quot;;
    public static final String TAG_2 = &amp;quot;tag 2&amp;quot;;
    public static final String TEST_DATE = &amp;quot;2016-01-01&amp;quot;;
    public static final String TEST_CONTENT = &amp;quot;content&amp;quot;;
    public static final String TEST_PRE_CONTENT = &amp;quot;&amp;lt;pre lang=\&amp;quot;java\&amp;quot;&amp;gt; java content &amp;lt;/pre&amp;gt;&amp;quot;;
    public static final String TEST_PRE_RESULT = &amp;quot;\n```prettyprint linenums\n java content \n```\n&amp;quot;;

    private MdTranslator sut = new MdTranslator();

    @Test
    public void translateDate() throws Exception {
        String dateAsString = TEST_DATE;
        SimpleDateFormat formatter = new SimpleDateFormat(MdTranslator.POST_DATE_FORMAT);
        Date date = formatter.parse(dateAsString);
        String translatedDate = sut.translateDate(date);
        assertThat(translatedDate, is(dateAsString));
    }

    @Test
    public void translateTags() {
        List&amp;lt;String&amp;gt; tags = new ArrayList&amp;lt;&amp;gt;(2);
        tags.add(TAG_1);
        tags.add(TAG_2);
        String translatedTags = sut.translateTags(tags);
        assertThat(translatedTags, is(TAG_1 + MdTranslator.TAG_DELIMITER + TAG_2));
    }

    @Test
    public void translateContent() {
        String translatedContent = sut.translateContent(TEST_CONTENT);
        assertThat(translatedContent, is(TEST_CONTENT));
    }

    @Test
    public void translateContentWithPreWithLanguage() {
        String translatedContent = sut.translateContent(TEST_PRE_CONTENT);
        assertThat(translatedContent, is(TEST_PRE_RESULT));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Todos funcionan menos el último, claro, hay que cambiar la implementación del &lt;em&gt;translateContent&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;public class MdTranslator {

    public static final String POST_DATE_FORMAT = &amp;quot;yyyy-MM-dd&amp;quot;;
    public static final String TAG_DELIMITER = &amp;quot;,&amp;quot;;


    public String translateDate(Date dateToTranslate) {
        DateFormat formatter = new SimpleDateFormat(POST_DATE_FORMAT);
        return formatter.format(dateToTranslate);
    }

    public String translateTags(Collection&amp;lt;String&amp;gt; tagsToTranslate) {
        return tagsToTranslate.stream().map(Object::toString).collect(Collectors.joining(TAG_DELIMITER));
    }

    public String translateContent(String contentToTranslate) {
        String translatedContent = translatePre(contentToTranslate);
        return translatedContent;
    }

    private String translatePre(String contentToTranslate) {
        String contentWithoutStartingPre = contentToTranslate.replaceAll(&amp;quot;&amp;lt;pre[^&amp;gt;]*&amp;gt;&amp;quot;, &amp;quot;\n```prettyprint linenums\n&amp;quot;);
        String contentWithoutEndingPre = contentWithoutStartingPre.replaceAll(&amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;, &amp;quot;\n```\n&amp;quot;);
        return contentWithoutEndingPre;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Con ésto ya bastaría, pero mirando el estilo, hay bastantes etiquetas &lt;code&gt;&amp;lt;h1&lt;/code&gt;&amp;gt; etc... para dar formato. Estas etiquetas no pegan nada en el diseño nuevo de la página, ya que el titular del post es un &lt;code&gt;&amp;lt;h4&lt;/code&gt;&amp;gt;, así que el &lt;code&gt;&amp;lt;h1&lt;/code&gt;&amp;gt; debería ser el &lt;code&gt;&amp;lt;h5&lt;/code&gt;&amp;gt; y sucesivamente... vamos a ello.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;public class MdTranslatorTest {

    public static final String TAG_1 = &amp;quot;tag 1&amp;quot;;
    public static final String TAG_2 = &amp;quot;tag 2&amp;quot;;
    public static final String TEST_DATE = &amp;quot;2016-01-01&amp;quot;;
    public static final String TEST_CONTENT = &amp;quot;content&amp;quot;;
    public static final String TEST_PRE_CONTENT = &amp;quot;&amp;lt;pre lang=\&amp;quot;java\&amp;quot;&amp;gt; java content &amp;lt;/pre&amp;gt;&amp;quot;;
    public static final String TEST_PRE_RESULT = &amp;quot;\n```prettyprint linenums\n java content \n```\n&amp;quot;;
    private static final String TEST_HEADING_CONTENT = &amp;quot;&amp;lt;h1&amp;gt; Title &amp;lt;/h1&amp;gt;&amp;lt;H2&amp;gt; Subtitle &amp;lt;/H2&amp;gt;&amp;quot;;
    private static final String TEST_HEADING_RESULT = &amp;quot;&amp;lt;h5&amp;gt; Title &amp;lt;/h5&amp;gt;&amp;lt;h6&amp;gt; Subtitle &amp;lt;/h6&amp;gt;&amp;quot;;

    private MdTranslator sut = new MdTranslator();

    @Test
    public void translateDate() throws Exception {
        String dateAsString = TEST_DATE;
        SimpleDateFormat formatter = new SimpleDateFormat(MdTranslator.POST_DATE_FORMAT);
        Date date = formatter.parse(dateAsString);
        String translatedDate = sut.translateDate(date);
        assertThat(translatedDate, is(dateAsString));
    }

    @Test
    public void translateTags() {
        List&amp;lt;String&amp;gt; tags = new ArrayList&amp;lt;&amp;gt;(2);
        tags.add(TAG_1);
        tags.add(TAG_2);
        String translatedTags = sut.translateTags(tags);
        assertThat(translatedTags, is(TAG_1 + MdTranslator.TAG_DELIMITER + TAG_2));
    }

    @Test
    public void translateContent() {
        String translatedContent = sut.translateContent(TEST_CONTENT);
        assertThat(translatedContent, is(TEST_CONTENT));
    }

    @Test
    public void translateContentWithPre() {
        String translatedContent = sut.translateContent(TEST_PRE_CONTENT);
        assertThat(translatedContent, is(TEST_PRE_RESULT));
    }

    @Test
    public void translateContentWithHeading() {
        String translatedContent = sut.translateContent(TEST_HEADING_CONTENT);
        assertThat(translatedContent, is(TEST_HEADING_RESULT));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;public class MdTranslator {

    public static final String POST_DATE_FORMAT = &amp;quot;yyyy-MM-dd&amp;quot;;
    public static final String TAG_DELIMITER = &amp;quot;,&amp;quot;;
    public static final String START_PRE = &amp;quot;&amp;lt;pre[^&amp;gt;]*&amp;gt;&amp;quot;;
    public static final String START_PRETTYPRINT = &amp;quot;\n```prettyprint linenums\n&amp;quot;;
    public static final String END_PRE = &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;;
    public static final String END_PRETTYPRINT = &amp;quot;\n```\n&amp;quot;;
    public static final String START_H1 = &amp;quot;&amp;lt;h1&amp;gt;&amp;quot;;
    public static final String START_H5 = &amp;quot;&amp;lt;h5&amp;gt;&amp;quot;;
    public static final String END_H1 = &amp;quot;&amp;lt;/h1&amp;gt;&amp;quot;;
    public static final String END_H5 = &amp;quot;&amp;lt;/h5&amp;gt;&amp;quot;;
    public static final String START_H2 = &amp;quot;&amp;lt;h2&amp;gt;&amp;quot;;
    public static final String START_H6 = &amp;quot;&amp;lt;h6&amp;gt;&amp;quot;;
    public static final String END_H2 = &amp;quot;&amp;lt;/h2&amp;gt;&amp;quot;;
    public static final String END_H6 = &amp;quot;&amp;lt;/h6&amp;gt;&amp;quot;;
    public static final String START_H3 = &amp;quot;&amp;lt;h3&amp;gt;&amp;quot;;
    public static final String START_H7 = &amp;quot;&amp;lt;h7&amp;gt;&amp;quot;;
    public static final String END_H3 = &amp;quot;&amp;lt;/h3&amp;gt;&amp;quot;;
    public static final String END_H7 = &amp;quot;&amp;lt;/h7&amp;gt;&amp;quot;;


    public String translateDate(Date dateToTranslate) {
        DateFormat formatter = new SimpleDateFormat(POST_DATE_FORMAT);
        return formatter.format(dateToTranslate);
    }

    public String translateTags(Collection&amp;lt;String&amp;gt; tagsToTranslate) {
        return tagsToTranslate.stream().map(Object::toString).collect(Collectors.joining(TAG_DELIMITER));
    }

    public String translateContent(String contentToTranslate) {
        String translatedContent = translatePre(contentToTranslate);
        translatedContent = translateHeadings(translatedContent);
        return translatedContent;
    }

    private String translatePre(String contentToTranslate) {
        String contentWithoutStartingPre = contentToTranslate.replaceAll(START_PRE, START_PRETTYPRINT);
        String contentWithoutEndingPre = contentWithoutStartingPre.replaceAll(END_PRE, END_PRETTYPRINT);
        return contentWithoutEndingPre;
    }

    private String translateHeadings(String contentToTranslate) {
        String contentWithoutStartingh1 = contentToTranslate.replace(START_H1, START_H5).replace(START_H1.toUpperCase(), START_H5);
        String contentWithoutEndingh1 = contentWithoutStartingh1.replace(END_H1, END_H5).replace(END_H1.toUpperCase(), END_H5);
        String contentWithoutStartingh2 = contentWithoutEndingh1.replace(START_H2, START_H6).replace(START_H2.toUpperCase(), START_H6);
        String contentWithoutEndingh2 = contentWithoutStartingh2.replace(END_H2, END_H6).replace(END_H2.toUpperCase(), END_H6);
        String contentWithoutStartingh3 = contentWithoutEndingh2.replace(START_H3, START_H7).replace(START_H3.toUpperCase(), START_H7);
        String contentWithoutEndingh3 = contentWithoutStartingh3.replace(END_H3, END_H7).replace(END_H3.toUpperCase(), END_H7);
        return contentWithoutEndingh3;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Que no digo que no haya forma más elegante de convertir las etiquetas de heading... pero de momento, servirá.&lt;/p&gt;&lt;p&gt;Y ya el (espero) último problema. Wordpress muchas veces mete elementos propios en etiquetas rollo &lt;em&gt;[caption]...[/caption]&lt;/em&gt;. Esta parte es complicada, porque en ese caso por ejemplo usaba una imagen subida al mismo wordpress y si bien podría hacer una petición para bajar la imagen y guardarla y tal... va a ser que no, lo que voy a hacer sencillamente es cargarme esas etiquetas (que al fin y al cabo solo son para embellecer) y dejar el contenido de las mismas, a ver que pasa.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class MdTranslatorTest {

    public static final String TAG_1 = &amp;quot;tag 1&amp;quot;;
    public static final String TAG_2 = &amp;quot;tag 2&amp;quot;;
    public static final String TEST_DATE = &amp;quot;2016-01-01&amp;quot;;
    public static final String TEST_CONTENT = &amp;quot;content&amp;quot;;
    public static final String TEST_PRE_CONTENT = &amp;quot;&amp;lt;pre lang=\&amp;quot;java\&amp;quot;&amp;gt; java content &amp;lt;/pre&amp;gt;&amp;quot;;
    public static final String TEST_PRE_RESULT = &amp;quot;\n```prettyprint linenums\n java content \n```\n&amp;quot;;
    private static final String TEST_HEADING_CONTENT = &amp;quot;&amp;lt;h1&amp;gt; Title &amp;lt;/h1&amp;gt;&amp;lt;H2&amp;gt; Subtitle &amp;lt;/H2&amp;gt;&amp;quot;;
    private static final String TEST_HEADING_RESULT = &amp;quot;&amp;lt;h5&amp;gt; Title &amp;lt;/h5&amp;gt;&amp;lt;h6&amp;gt; Subtitle &amp;lt;/h6&amp;gt;&amp;quot;;
    public static final String TEST_WORDPRESS_TAGS_CONTENT = &amp;quot;[caption id=&amp;#39;image&amp;#39;] image [/caption]&amp;quot;;
    public static final String TEST_WORDPRESS_TAGS_RESULT = &amp;quot; image &amp;quot;;

    private MdTranslator sut = new MdTranslator();

    @Test
    public void translateDate() throws Exception {
        String dateAsString = TEST_DATE;
        SimpleDateFormat formatter = new SimpleDateFormat(MdTranslator.POST_DATE_FORMAT);
        Date date = formatter.parse(dateAsString);
        String translatedDate = sut.translateDate(date);
        assertThat(translatedDate, is(dateAsString));
    }

    @Test
    public void translateTags() {
        List&amp;lt;String&amp;gt; tags = new ArrayList&amp;lt;&amp;gt;(2);
        tags.add(TAG_1);
        tags.add(TAG_2);
        String translatedTags = sut.translateTags(tags);
        assertThat(translatedTags, is(TAG_1 + MdTranslator.TAG_DELIMITER + TAG_2));
    }

    @Test
    public void translateContent() {
        String translatedContent = sut.translateContent(TEST_CONTENT);
        assertThat(translatedContent, is(TEST_CONTENT));
    }

    @Test
    public void translateContentWithPre() {
        String translatedContent = sut.translateContent(TEST_PRE_CONTENT);
        assertThat(translatedContent, is(TEST_PRE_RESULT));
    }

    @Test
    public void translateContentWithHeading() {
        String translatedContent = sut.translateContent(TEST_HEADING_CONTENT);
        assertThat(translatedContent, is(TEST_HEADING_RESULT));
    }

    @Test
    public void translateContentWithWordpressTags() {
        String translatedContent = sut.translateContent(TEST_WORDPRESS_TAGS_CONTENT);
        assertThat(translatedContent, is(TEST_WORDPRESS_TAGS_RESULT));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class MdTranslator {

    public static final String POST_DATE_FORMAT = &amp;quot;yyyy-MM-dd&amp;quot;;
    public static final String TAG_DELIMITER = &amp;quot;,&amp;quot;;
    public static final String START_PRE = &amp;quot;&amp;lt;pre[^&amp;gt;]*&amp;gt;&amp;quot;;
    public static final String START_PRETTYPRINT = &amp;quot;\n```prettyprint linenums\n&amp;quot;;
    public static final String END_PRE = &amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;;
    public static final String END_PRETTYPRINT = &amp;quot;\n```\n&amp;quot;;
    public static final String START_H1 = &amp;quot;&amp;lt;h1&amp;gt;&amp;quot;;
    public static final String START_H5 = &amp;quot;&amp;lt;h5&amp;gt;&amp;quot;;
    public static final String END_H1 = &amp;quot;&amp;lt;/h1&amp;gt;&amp;quot;;
    public static final String END_H5 = &amp;quot;&amp;lt;/h5&amp;gt;&amp;quot;;
    public static final String START_H2 = &amp;quot;&amp;lt;h2&amp;gt;&amp;quot;;
    public static final String START_H6 = &amp;quot;&amp;lt;h6&amp;gt;&amp;quot;;
    public static final String END_H2 = &amp;quot;&amp;lt;/h2&amp;gt;&amp;quot;;
    public static final String END_H6 = &amp;quot;&amp;lt;/h6&amp;gt;&amp;quot;;
    public static final String START_H3 = &amp;quot;&amp;lt;h3&amp;gt;&amp;quot;;
    public static final String END_H3 = &amp;quot;&amp;lt;/h3&amp;gt;&amp;quot;;
    public static final String START_WORDPRESS_CAPTION = &amp;quot;\\[caption[^\\]]*\\]&amp;quot;;
    public static final String END_WORDPRESS_CAPTION = &amp;quot;\\[/caption\\]&amp;quot;;


    public String translateDate(Date dateToTranslate) {
        DateFormat formatter = new SimpleDateFormat(POST_DATE_FORMAT);
        return formatter.format(dateToTranslate);
    }

    public String translateTags(Collection&amp;lt;String&amp;gt; tagsToTranslate) {
        return tagsToTranslate.stream().map(Object::toString).collect(Collectors.joining(TAG_DELIMITER));
    }

    public String translateContent(String contentToTranslate) {
        String translatedContent = translatePre(contentToTranslate);
        translatedContent = translateHeadings(translatedContent);
        translatedContent = deleteWordpressImages(translatedContent);
        return translatedContent;
    }

    private String deleteWordpressImages(String contentToTranslate) {
        String contentWithoutStartingTag = contentToTranslate.replaceAll(START_WORDPRESS_CAPTION, StringUtils.EMPTY);
        String contentWithoutEndingTag = contentWithoutStartingTag.replaceAll(END_WORDPRESS_CAPTION, StringUtils.EMPTY);
        return contentWithoutEndingTag;
    }

    private String translatePre(String contentToTranslate) {
        String contentWithoutStartingPre = contentToTranslate.replaceAll(START_PRE, START_PRETTYPRINT);
        String contentWithoutEndingPre = contentWithoutStartingPre.replaceAll(END_PRE, END_PRETTYPRINT);
        return contentWithoutEndingPre;
    }

    private String translateHeadings(String contentToTranslate) {
        String contentWithoutStartingh1 = contentToTranslate.replace(START_H1, START_H5).replace(START_H1.toUpperCase(), START_H5);
        String contentWithoutEndingh1 = contentWithoutStartingh1.replace(END_H1, END_H5).replace(END_H1.toUpperCase(), END_H5);
        String contentWithoutStartingh2 = contentWithoutEndingh1.replace(START_H2, START_H6).replace(START_H2.toUpperCase(), START_H6);
        String contentWithoutEndingh2 = contentWithoutStartingh2.replace(END_H2, END_H6).replace(END_H2.toUpperCase(), END_H6);
        String contentWithoutStartingh3 = contentWithoutEndingh2.replace(START_H3, START_H6).replace(START_H3.toUpperCase(), START_H6);
        String contentWithoutEndingh3 = contentWithoutStartingh3.replace(END_H3, END_H6).replace(END_H3.toUpperCase(), END_H6);
        return contentWithoutEndingh3;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Un detalle más revisando la documentación de &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax#html&quot;&gt;Markdown&lt;/a&gt;, te recomiendan que los elementos a nivel de bloque vayan precedidos y sucedidos por una línea en blanco, eso significa más trabajo para el translator. En particular, tengo que tocar el tratamiento de los heading para añadirlo y además, procesar &lt;em&gt;&lt;p&gt;&lt;/em&gt;, &lt;em&gt;&lt;ul&gt;&lt;/em&gt;, &lt;em&gt;&lt;ol&gt;&lt;/em&gt;, &lt;em&gt;&lt;blockquote&gt;&lt;/em&gt;, &lt;em&gt;&lt;table&gt;&lt;/em&gt; y &lt;em&gt;&lt;div&gt;&lt;/em&gt;. Hay algunos más pero creo que con eso ya voy cubierto, si no, cuestión de ir añadiendo más casos.&lt;/p&gt;&lt;p&gt;&lt;code&gt;prettyprint
&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;prettyprint
&lt;/code&gt;&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Wordpress to JBake - Escritura</title>
      <link>http://www.aguasnegras.es/blog/2016/06/05-wp2jbake-escritura.html</link>
      <pubDate>dom, 5 jun 2016 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2016/06/05-wp2jbake-escritura.html</guid>
      	<description>
	&lt;p&gt;Retomando la migración del blog, una vez resuelta la parte de leer los posts, hay que hacer la escritura. El enfoque pasa por lo siguiente:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Tener una plantilla de post que se leerá en el constructor. Esta plantilla tendrá placeholders para saber donde van los campos.&lt;/li&gt;
  &lt;li&gt;Tratar según que campos, por ejemplo los tags habrá que representarlos como un string y separados por comas, las etiquetas &lt;code&gt;&amp;lt;pre&lt;/code&gt;&amp;gt; que indican código habrá que convertiras a prettyprint.&lt;/li&gt;
  &lt;li&gt;Escribir el archivo, a ser posible usando async I/O, así no se bloquea.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Empezando por lo primero, la plantilla irá en &lt;em&gt;src/main/resources&lt;/em&gt; y será la siguiente&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;title=$title$
date=$date$
type=post
tags=$tags$
status=published
~~~~~~
$content$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Los placeholders he decidido que empiecen y terminen por $ para mayor seguridad. El test sería el siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void writerWithValidDestination() {
    sut = new MdWriter(&amp;quot;src/test/destination&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y la implementación, aprovechando para lo cual he simplificado la clase usando las clases nuevas de Java 8 &lt;em&gt;Files&lt;/em&gt; y &lt;em&gt;Path&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class MdWriter {

    private String template;

    private String destinationFolder;

    public MdWriter(String destinationFolder) {
        if (StringUtils.isEmpty(destinationFolder) || !isWritable(destinationFolder)) {
            throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
        } else {
            readTemplate();
            this.destinationFolder = destinationFolder;
        }
    }

    private void readTemplate() {
        try {
            template = new String(Files.readAllBytes(Paths.get(&amp;quot;src/main/resources/template.md&amp;quot;)));
        } catch (IOException e) {
            throw new IllegalStateException(&amp;quot;Could not read post template template.md: &amp;quot; + e.getMessage());
        }
    }

    private boolean isWritable(String destination) {
        Path destinationPath = Paths.get(destination);
        if (Files.exists(destinationPath)) {
            return Files.isWritable(destinationPath);
        } else {
            return Files.isWritable(destinationPath.getParent());
        }
    }

    public File write(Post post) {
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora tengo que crear la estructura de archivos en la que va el post, es decir, tengo que verificar si existe existe la ruta del tipo detinationFolder/yyyy/mm y ahí crear un archivo de nombre dd-tituloDelPost y por último, escribirlo. La verdad que todo esto es MUY fácil con &lt;em&gt;Paths&lt;/em&gt; y &lt;em&gt;Files&lt;/em&gt;, así que ya no hace falta usar los &lt;em&gt;commons-io&lt;/em&gt;, al menos para ésto.&lt;br/&gt;Los tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class MdWriterTest {

    public static final String POST_DATE_FORMAT = &amp;quot;yyyy-MM-dd&amp;quot;;
    public static final String TEST_POST_CONTENT = &amp;quot;content&amp;quot;;
    public static final String TEST_POST_TITLE = &amp;quot;title&amp;quot;;
    public static final Date TEST_POST_DATE = new Date();
    public static final String POST = &amp;quot;post&amp;quot;;
    public static final String EMPTY_TAGS = &amp;quot;&amp;quot;;
    public static final String PUBLISHED = &amp;quot;published&amp;quot;;
    public static final String METADATA_SEPARATOR = &amp;quot;~~~~~~&amp;quot;;
    public static final String FIRST_TAG = &amp;quot;tag1&amp;quot;;
    public static final String SECOND_TAG = &amp;quot;tag2&amp;quot;;
    private MdWriter sut;

    private String destination = &amp;quot;src/test/destination&amp;quot;;

    @Before
    public void setUp() throws IOException {
        cleanDestination();
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithoutDestination() {
        sut = new MdWriter(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithEmptyDestination() {
        sut = new MdWriter(&amp;quot;&amp;quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestination() {
        File destination = new File(&amp;quot;destination&amp;quot;);
        destination.mkdir();
        destination.deleteOnExit();
        destination.setReadOnly();
        sut = new MdWriter(destination.getAbsolutePath());
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestinationParent() {
        File destinationParent = new File(&amp;quot;destinationParent&amp;quot;);
        destinationParent.mkdir();
        destinationParent.deleteOnExit();
        destinationParent.setReadOnly();
        sut = new MdWriter(destinationParent.getAbsolutePath() + File.separator + &amp;quot;destination&amp;quot;);
    }

    @Test
    public void writerWithValidDestination() {
        sut = new MdWriter(destination);
    }

    @Test(expected =  IllegalArgumentException.class)
    public void writeEmptyPost() {
        sut = new MdWriter(destination);
        sut.write(new Post());
        new File(destination).delete();
    }

    @Test
    public void writePostWithoutTags() throws IOException {
        sut = new MdWriter(destination);
        Post post = new Post().withContent(TEST_POST_CONTENT).withTitle(TEST_POST_TITLE).withPublishingDate(TEST_POST_DATE);
        File postFile = sut.write(post);
        assertThat(postFile, notNullValue());
        List&amp;lt;String&amp;gt; lines = Files.readAllLines(Paths.get(postFile.getPath()));
        assertThat(getValue(lines.get(0)), is(post.getTitle()));
        assertThat(getValue(lines.get(1)), is(getPostDate(post)));
        assertThat(getValue(lines.get(2)), is(POST));
        assertThat(getValue(lines.get(3)), is(EMPTY_TAGS));
        assertThat(getValue(lines.get(4)), is(PUBLISHED));
        assertThat(getValue(lines.get(5)), is(METADATA_SEPARATOR));
        assertThat(lines.get(6), is(post.getContent()));
        cleanDestination();
    }

    @Test
    public void writePostWithTags() throws IOException {
        sut = new MdWriter(destination);
        Post post = new Post().withContent(TEST_POST_CONTENT).withTitle(TEST_POST_TITLE).withPublishingDate(TEST_POST_DATE).withTag(FIRST_TAG).withTag(SECOND_TAG);
        File postFile = sut.write(post);
        assertThat(postFile, notNullValue());
        List&amp;lt;String&amp;gt; lines = Files.readAllLines(Paths.get(postFile.getPath()));
        assertThat(getValue(lines.get(0)), is(post.getTitle()));
        assertThat(getValue(lines.get(1)), is(getPostDate(post)));
        assertThat(getValue(lines.get(2)), is(POST));
        assertThat(getValue(lines.get(3)), is(FIRST_TAG+&amp;quot;,&amp;quot;+SECOND_TAG));
        assertThat(getValue(lines.get(4)), is(PUBLISHED));
        assertThat(getValue(lines.get(5)), is(METADATA_SEPARATOR));
        assertThat(lines.get(6), is(post.getContent()));
        cleanDestination();
    }

    private String getPostDate(Post post) {
        DateFormat formatter = new SimpleDateFormat(POST_DATE_FORMAT);
        return formatter.format(post.getPublishingDate());
    }

    private String getValue(String line) {
        int valueStart = line.indexOf(&amp;quot;=&amp;quot;)+1;
        return line.substring(valueStart);
    }

    private void cleanDestination() throws IOException {
        if (Files.exists(Paths.get(destination))) {
            Files.walkFileTree(Paths.get(destination), new SimpleFileVisitor&amp;lt;Path&amp;gt;() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    Files.delete(file);
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                    Files.delete(dir);
                    return FileVisitResult.CONTINUE;
                }

            });
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y la implementación:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class MdWriter {

    public static final String TEMPLATE = &amp;quot;src/main/resources/template.md&amp;quot;;
    public static final String TITLE = &amp;quot;$title$&amp;quot;;
    public static final String DATE = &amp;quot;$date$&amp;quot;;
    public static final String TAGS = &amp;quot;$tags$&amp;quot;;
    public static final String CONTENT = &amp;quot;$content$&amp;quot;;
    public static final String POST_DATE_FORMAT = &amp;quot;yyyy-MM-dd&amp;quot;;
    public static final String POST_EXTENSION = &amp;quot;.md&amp;quot;;
    public static final String DATE_TITLE_SEPARATOR = &amp;quot;-&amp;quot;;

    private String template;

    private String destinationFolder;

    public MdWriter(String destinationFolder) {
        if (StringUtils.isEmpty(destinationFolder) || !isWritable(destinationFolder)) {
            throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
        } else {
            readTemplate();
            this.destinationFolder = destinationFolder;
        }
    }

    private void readTemplate() {
        try {
            template = new String(Files.readAllBytes(Paths.get(TEMPLATE)));
        } catch (IOException e) {
            throw new IllegalStateException(&amp;quot;Could not read post template template.md: &amp;quot; + e.getMessage());
        }
    }

    private boolean isWritable(String destination) {
        Path destinationPath = Paths.get(destination);
        if (Files.exists(destinationPath)) {
            return Files.isWritable(destinationPath);
        } else {
            return Files.isWritable(destinationPath.getParent());
        }
    }

    public File write(Post post) {
        validatePost(post);
        Path destinationPath = getDestinationPath(post);
        createDestinationPath(destinationPath);
        String postMarkdown = getPostMarkdown(post);
        try {
            Files.write(destinationPath, postMarkdown.getBytes()
                    , StandardOpenOption.CREATE_NEW);
        } catch (IOException e) {
            throw new IllegalStateException(&amp;quot;Error writing file &amp;quot; + destinationPath.toString() + &amp;quot;: &amp;quot; + e.getLocalizedMessage());
        }
        return destinationPath.toFile();
    }

    private void validatePost(Post post) {
        if (StringUtils.isEmpty(post.getTitle()) || post.getPublishingDate() == null || StringUtils.isEmpty(post.getContent())) {
            throw new IllegalArgumentException();
        }
    }

    private String getPostMarkdown(Post post) {
        String postMarkdown = template.replace(TITLE, post.getTitle());
        postMarkdown = postMarkdown.replace(DATE, getPostDate(post.getPublishingDate()));
        postMarkdown = postMarkdown.replace(TAGS, post.getTags().stream().map(Object::toString).collect(Collectors.joining(&amp;quot;,&amp;quot;)));
        postMarkdown = postMarkdown.replace(CONTENT, post.getContent());
        return postMarkdown;
    }

    private String getPostDate(Date publishingDate) {
        DateFormat formatter = new SimpleDateFormat(POST_DATE_FORMAT);
        return formatter.format(publishingDate);
    }

    private void createDestinationPath(Path destinationPath) {
        try {
            if (!Files.exists(destinationPath.getParent())) {
                Files.createDirectories(destinationPath.getParent());
            }
        } catch (IOException e) {
            throw new IllegalStateException(&amp;quot;Error creating destination path &amp;quot; + destinationPath + &amp;quot;: &amp;quot; + e.getMessage());
        }
    }

    private Path getDestinationPath(Post post) {
        Calendar publishedCalendar = getPublishedCalendar(post);
        Path destinationPath = Paths.get(destinationFolder, Integer.toString(publishedCalendar.get(Calendar.YEAR)),
                Integer.toString(publishedCalendar.get(Calendar.MONTH)), Integer.toString(publishedCalendar.get(Calendar.DAY_OF_MONTH)) +
                        DATE_TITLE_SEPARATOR + post.getTitle() + POST_EXTENSION);
        return destinationPath;
    }

    private Calendar getPublishedCalendar(Post post) {
        Calendar publishedCalendar = Calendar.getInstance();
        publishedCalendar.setTime(post.getPublishingDate());
        return publishedCalendar;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bueno, pues ya esta, ya solo faltarían las pruebas de &lt;em&gt;Wp2JBake&lt;/em&gt; como tales, es decir, la integración. Todavía no he tocado nada de etiquetas especiales, ni he considerado el hecho de que se exportan posts que se consideran borradores (aquellos que tienen de fecha de publicación el 1AC), pero eso me debe dar la cara en las pruebas de integración.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Spring Boot Developer Tools e Intellij IDEA</title>
      <link>http://www.aguasnegras.es/blog/2016/05/30-springdevtoolsintellij.html</link>
      <pubDate>lun, 30 may 2016 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2016/05/30-springdevtoolsintellij.html</guid>
      	<description>
	&lt;p&gt;Una de las mejores incorporaciones que tuvo Spring Boot en la versión 1.3 fueron las &lt;a href=&quot;https://spring.io/blog/2015/06/17/devtools-in-spring-boot-1-3&quot;&gt;Developer Tools&lt;/a&gt;.&lt;br/&gt;De entre toda la funcionalidad, lo que me parece mas útil es sin lugar a dudas el automatic restart, que relanza la aplicación en cuanto detecta cambios en un&lt;br/&gt;fichero que esta en el classpath y el LiveReload, que en conjunción con un plugin de Chrome detecta cuando ha habido cambios en la aplicación (como un reinicio)&lt;br/&gt;y refresca automáticamente la página.&lt;/p&gt;&lt;p&gt;Juntando estas dos cosas, y dejando de lado el consumo de recursos, codificar en Java se convierte prácticamente en lo mismo que trabajar con un lenguaje de scripting&lt;br/&gt;como PHP.&lt;/p&gt;&lt;p&gt;Sin embargo, el soporte de los developers tools no es automático del todo en Intellij IDEA, el IDE que más suelo utilizar en casa, para ello hay que &lt;a href=&quot;https://patrickgrimard.io/2016/01/18/spring-boot-devtools-first-look/&quot;&gt;habilitar&lt;br/&gt;dos opciones&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;En Settings (ctrl-alt-s) &amp;gt; Build, Execution, Deployment &amp;gt; Compiler hay que marcar &quot;Make project automatically&quot;&lt;/li&gt;
  &lt;li&gt;En el registro que se puede acceder mediante ctrl-shift-a y buscando &quot;Registry&quot; hay que habilitar la clave compiler.automake.allow.when.app.running para que el&lt;br/&gt;automake funcione también mientras la aplicación esta arrancada.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Con ésto, y si tenemos un equipo suficientemente potente (aunque mi portátil tiene ya 5 años lo mueve bastante bien), cualquier cambio en nuestras clases se cargará&lt;br/&gt;automáticamente al reiniciar la aplicación. Eso sí, dado que Intellij IDEA guarda automáticamente los archivos cuando detecta cambios, esto puede dar lugar a algunos&lt;br/&gt;errores o reinicios en falso (por ejemplo, cuando estamos escribiendo un método y nos vamos a StackOverflow a resolver alguna duda). Para eso se pueden ajustar las&lt;br/&gt;opciones de autosave tal y como se explica en la misma &lt;a href=&quot;https://www.jetbrains.com/help/idea/2016.1/saving-and-reverting-changes.html&quot;&gt;documentación del IDE&lt;/a&gt;.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Wordpress to JBake - Parseo</title>
      <link>http://www.aguasnegras.es/blog/2016/03/20-wp2jbake-parseo.html</link>
      <pubDate>dom, 20 mar 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/03/20-wp2jbake-parseo.html</guid>
      	<description>
	&lt;p&gt;Pues ahora que ya tengo el constructor y construyo un objeto siempre que, al menos es coherente, toca parsear el xml para extraer los datos.&lt;br/&gt;En Java, esencialmente hay tres formas de parsear xml, todas dentro de lo que se denomina Java XML Processing API, &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/index.html&quot;&gt;JAXP&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/sax/index.html&quot;&gt;SAX&lt;/a&gt;: La API originaria, orientada a eventos. Muy rápida, muy eficiente y muy farragosa. Técnicamente es una API de streaming mediante push, es decir, nosotros arrancamos el procesamiento del documento y la API empieza a funcionar mandándonos eventos conforme va encontrando elementos.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/dom/index.html&quot;&gt;DOM&lt;/a&gt;: La API orientada a objetos, representa el XML como un árbol en memoria. Muy fácil de acceder, muy tragón de recursos. Técnicamente, se representa el árbol del DOM en memoria y listo, se puede acceder libremente, por ejemplo usando XPath.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/stax/index.html&quot;&gt;StAX&lt;/a&gt;: A partir del JDK 1.5 se encuentra disponible esta API que es un modelo mixto, se basa en un modelo de streaming (parecido a SAX) pero más sencillo de utilizar y además permite escribir. Técnicamente se define como una API de streming mediante pull, es decir, que somos nosotros los que vamos indicanto los elementos que queremos acceder. Eso sí, al ser de streaming solo permite avanzar en el documento, es decir, no podemos ignorar el elemento 1, tratar el 2 y en función de este retroceder a tratar el 1.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;En mi caso en particular, y dado que el modelo de &quot;ir hacia delante&quot; se adapta perfectamente al caso de uso (ya que simplemente estoy emparejando), pero tampoco necesito tantísima eficiencia ni tengo ganas de fastidiarme la vida, voy a utilizar StAX.&lt;/p&gt;&lt;p&gt;Pero lo primero, ahora que tengo que trabajar &quot;en serio&quot; es utilizar datos de verdad para las pruebas. Para eso hay dos opciones:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Guardo un XML de pruebas en forma de un String en un archivo .java y lo leo de ahí.&lt;/li&gt;
  &lt;li&gt;Guardo un archivo XML como tal.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Pues como que la primera opción es una tontería, he optado por la segunda. He sacado la exportación de datos que proporciona Wordpress y he dejado unos cuantos posts que sean más o menos representativos y listo. Lo guardo en &lt;em&gt;src/resources/wp-source.xml&lt;/em&gt;. Antes de seguir, ya no tiene sentido que los tests sigan usando el &lt;em&gt;pom.xml&lt;/em&gt; para las pruebas, así que lo cambio y lo lanzo. Todo en verde, como cabía esperar.&lt;/p&gt;&lt;p&gt;Ahora bien, ya tengo mi objeto de la clase Wp2JBake creado con el origen y el destino debidamente especificado, ¿como arranco el procesamiento? Hay que tener en cuenta que realmente el método de proceso no tiene por qué devolver nada, ya que el resultado efectivo de la salida es una estructura de archivos con el resultado de la conversión.&lt;br/&gt;Sin embargo, creo que es &quot;gratis&quot; devolver los elementos que se han generado y así se posibilita poder comprobar el resultado de la generación.&lt;/p&gt;&lt;p&gt;Así que primero el test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void processEmptyXML() {
    sut = new Wp2JBake(&amp;quot;src/test/resources/empty.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
    assertThat(markdowns, is(empty()));
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.delete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Obviamente, esta en rojo, allá va la implementación:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
    return new HashSet&amp;lt;File&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y aquí, ya voy devolviendo un Set (porque todos los elementos serán distintos, cada archivo representa un post y cada post es único) y uso uno no ordenado, porque en realidad me dá igual el orden de iteración, ya que &lt;a href=&quot;../02/04-wp2jbake.html&quot;&gt;como decidí&lt;/a&gt; los archivos vendrán ordenados por su ruta, es decir, si existen, por definición estan ordenados.&lt;/p&gt;&lt;p&gt;Vale, y ahora, test de verdad:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void processXML() {
    sut = new Wp2JBake(&amp;quot;src/test/resources/wp-source.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
    assertThat(markdowns, is(not(empty())));
    for (File markdown: markdowns) {
        assertThat(markdown.exists(), is(true));
    }
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.delete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora tengo que modificar el método &lt;em&gt;generateJBakeMarkdown&lt;/em&gt; para que genere los archivos Markdown. En un principio hay dos formas de hacer ésto:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Parseo el XML, genero una estructura de datos en memoria (una representación de los posts, vaya) y después la recorro y la paso a los archivos markdown. Desventaja, que para eso para qué demonios uso StAX y el streaming, si voy a comer memoria uso DOM y listo.&lt;/li&gt;
  &lt;li&gt;Parseo el XML y cada vez que se detecte un item (un post) lo voy escribiendo dinámicamente. Creo que esta opción es más complicada, pero más ligera.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Vamos a por 2, para ello leeré el XML y lo volcaré... pero un momento, una cosa es saber leer el XML y otra escribir el Markdown, es decir, que mi clase lectora (_Wp2JBake_) a su vez debe comunicarse (usar) otra para escribir (_MdWriter_).&lt;br/&gt;Pensando un poco más sobre esta clase &lt;em&gt;MdWriter&lt;/em&gt;... debería recibir como parámetro en su constructor el destino de las escrituras y eso me lleva a pensar, que realmente es a ella a la que le corresponde comprobar si es un destino legal, es decir, que el constructor de &lt;em&gt;Wp2JBake&lt;/em&gt; ahora quedaría así (también he aprovechado y &lt;em&gt;origin&lt;/em&gt; lo he guardado en un atributo de la clase):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    } else {
        this.origin = origin;
    }
    this.mdWriter = new MdWriter(destination);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Mientras que &lt;em&gt;MdWriter&lt;/em&gt; sería así:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class MdWriter {

    private File destinationFolder;

    public MdWriter(String destination) {
        if (StringUtils.isEmpty(destination) || !isWritable(destination)) {
            throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
        } else {
            destinationFolder = new File(destination);
        }
    }

    private boolean isWritable(String destination) {
        File destinationFolder = new File(destination);
        if (destinationFolder.exists()) {
            return destinationFolder.canWrite();
        } else {
            return isWritableDestinationParent(destinationFolder);
        }
    }

    private boolean isWritableDestinationParent(File destinationFolder) {
        File destinationParent = getDestinationParent(destinationFolder);
        return destinationParent.canWrite();
    }

    private File getDestinationParent(File destinationFolder) {
        String parentPath = destinationFolder.getParent();
        if (parentPath == null) {
            parentPath = &amp;quot;&amp;quot;;
        }
        return new File(parentPath);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por cierto que la teoría TDDista dice que esto no debería hacerse, que primero hay que pasar el test y después ponerse a refactorizar y tal... Hombre, yo eso no lo comparto tanto, creo que esta bien ir pensando un poco las cosas. Además, como ya tengo hechos los tests, los puedo volver a ejecutar para ver que no me he cargado nada.&lt;br/&gt;Que hablando de las pruebas, ahora tengo que crear las pruebas propias de esta nueva clase y llevarme todas las encargadas de testear la corrección del directorio destino a esa clase. Al separarlo además ya no tengo que diferenciar entre los tipos de excepción (era muy cantoso que estaba pasando del Single Responsability) y el código queda mucho más limpio:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class Wp2JBakeTests {

    private Wp2JBake sut;

    @Test(expected = IllegalArgumentException.class)
    public void buildWithoutParameters() {
        sut = new Wp2JBake(null, null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithoutOrigin() {
        sut = new Wp2JBake(null, &amp;quot;foo&amp;quot;);

    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithEmptyOrigin() {
        sut = new Wp2JBake(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithInvalidOrigin() {
        sut = new Wp2JBake(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;);
    }

    @Test
    public void buildWithValidParameters() {
        sut = new Wp2JBake(&amp;quot;src/test/resources/wp-source.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    }

    @Test
    public void processEmptyXML() {
        sut = new Wp2JBake(&amp;quot;src/test/resources/empty.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
        Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
        assertThat(markdowns, is(empty()));
    }

    @Test
    public void processXML() {
        sut = new Wp2JBake(&amp;quot;src/test/resources/wp-source.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
        Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
        assertThat(markdowns, is(not(empty())));
        for (File markdown: markdowns) {
            assertThat(markdown.exists(), is(true));
        }
        File destination = new File(&amp;quot;destination&amp;quot;);
        destination.delete();
    }
}

public class MdWriterTest {

    private MdWriter sut;

    @Test(expected = IllegalArgumentException.class)
    public void writerWithoutDestination() {
        sut = new MdWriter(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithEmptyDestination() {
        sut = new MdWriter(&amp;quot;&amp;quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestination() {
        File destination = new File(&amp;quot;destination&amp;quot;);
        destination.mkdir();
        destination.deleteOnExit();
        destination.setReadOnly();
        sut = new MdWriter(destination.getAbsolutePath());
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestinationParent() {
        File destinationParent = new File(&amp;quot;destinationParent&amp;quot;);
        destinationParent.mkdir();
        destinationParent.deleteOnExit();
        destinationParent.setReadOnly();
        sut = new MdWriter(destinationParent.getAbsolutePath() + File.separator + &amp;quot;destination&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bueno, pues ahora tengo que leer el XML e ir cargando los Strings que el escritor se encargará de volcar a disco... muy bien. Lo primer es crear la factoría de eventos. Por cierto, menuda bazofia el tutorial oficial de Oracle, menos mal que &lt;a href=&quot;http://www.vogella.com/tutorials/JavaXML/article.html&quot;&gt;Lars Vogel&lt;/a&gt; tiene un grandísimo tutorial (danke schön Lars!):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
        XMLEventReader eventReader = getEventReader();
        return new HashSet&amp;lt;File&amp;gt;();
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&amp;quot;Could not find origin file: &amp;quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Could not read origin file: &amp;quot; + e.getMessage());
        }
        return eventReader;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;He optado por lanzar un IllegalStateException si ocurre alguna de las excepciones, ya que eso no debería ocurrir y a lo que lleva es exactamente a eso, un estado ilegal del programa :)&lt;br/&gt;Hmmm... por otra parte, tengo la prueba con el XML vacío, pero ahora que lo pienso ¡¡¡no tengo ninguna con un XML inválido!!! Me creo un XML &lt;em&gt;invalid.xml&lt;/em&gt; que contiene solo la cabecera con un número de versión que no existe:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;&amp;lt;?xml version=&amp;quot;-1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y su test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test(expected = IllegalStateException.class)
public void processInvalidXML() {
    sut = new Wp2JBake(&amp;quot;src/test/resources/invalid.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Me esta empezando a parecer que la lectura también debería ir en otra clase y &lt;em&gt;Wp2JBake&lt;/em&gt; tan solo orquestrar la lectura con la escritura... pero bueno, ya iremos viendo de momento sigo, así. Toca tratar los eventos. El tutorial hace un típico bucle while con el eventReader que implementa &lt;em&gt;Iterator&lt;/em&gt;, pero claro, el tutorial es antiguo, al fin y al cabo y pensándolo bien... yo lo que quiero hacer es un filter y un collect, es decir, que puedo usar la API de Streams de Java 8. La única historia es convertir el &lt;em&gt;XMLEventReader&lt;/em&gt; a un &lt;em&gt;Stream&lt;XMLEvent&gt;&lt;/em&gt;, pero eso es relativamente fácil:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
    XMLEventReader eventReader = getEventReader();
    Iterable&amp;lt;XMLEvent&amp;gt; eventsIterable = () -&amp;gt; eventReader;
    Stream&amp;lt;XMLEvent&amp;gt; xmlEvents = StreamSupport.stream(eventsIterable.spliterator(), false);
    return new HashSet&amp;lt;File&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bueno, pues después de echar hora y pico probando con filter, map, flatmap etc, hay un problema, y es que StAX entiende todo el documento secuencialmente, con lo cual no puedo hacer un filter y quedarme solo con los elemntos de tipo &lt;em&gt;item&lt;/em&gt; y después acceder a los elementos que contienen estos, porque un elemento esta suelto, así que nada, toca iteradores y bucles for de toda la vida. Para que sea más entendible (y orientado a objetos), me voy a crear una clase &lt;em&gt;Post&lt;/em&gt; para ir guardando los resultados y después volcarlos al archivo pertinente.&lt;br/&gt;Esta clase la monto con una API fluida para que la construcción me sea más sencilla y los correspondientes getters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class Post {
    private String title;

    private LocalDate publishingDate;

    private Set&amp;lt;String&amp;gt; tags = new TreeSet&amp;lt;&amp;gt;();

    private String content;

    public Post () {

    }

    public Post withTitle(String title) {
        this.title = title;
        return this;
    }

    public Post withPublishingDate(LocalDate publishingDate) {
        this.publishingDate = publishingDate;
        return this;
    }

    public Post withTag(String tag) {
        this.tags.add(tag);
        return this;
    }

    public Post withContent(String content) {
        this.content = content;
        return this;
    }

    public String getTitle() {
        return title;
    }

    public LocalDate getPublishingDate() {
        return publishingDate;
    }

    public Set&amp;lt;String&amp;gt; getTags() {
        return tags;
    }

    public String getContent() {
        return content;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;En fín, ya han pasado como tres horas y el test sigue sin funcionar... me deprimo...&lt;br/&gt;Sigo con el for, la estrategia es muy sencilla, si detecto un elemento &lt;em&gt;item&lt;/em&gt;, creo un nuevo &lt;em&gt;Post&lt;/em&gt; y conforme vaya detectando los elementos &lt;em&gt;title&lt;/em&gt;, &lt;em&gt;pubDate&lt;/em&gt;, &lt;em&gt;category&lt;/em&gt; y &lt;em&gt;content&lt;/em&gt; voy invocando a los métodos &lt;em&gt;with*&lt;/em&gt; del &lt;em&gt;Post&lt;/em&gt;. En el momento que detecte el cierre del &lt;em&gt;item&lt;/em&gt;, escribo a disco:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
    XMLEventReader eventReader = getEventReader();
    Iterable&amp;lt;XMLEvent&amp;gt; eventsIterable = () -&amp;gt; eventReader;
    Stream&amp;lt;XMLEvent&amp;gt; xmlEvents = StreamSupport.stream(eventsIterable.spliterator(), false);
    return new HashSet&amp;lt;File&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Desafortunadamente, el tema es más complejo de lo que parecía. Dado que StAX solo lee en un sentido (palante), de poco me sirve la API de streams de Java 8, ya que tengo que ir tomando decisiones en función del elemento que llegue, por ejemplo, un elemento &lt;em&gt;title&lt;/em&gt; se debe ignorar salvo que previamente se haya recibido un &lt;em&gt;item&lt;/em&gt;.&lt;br/&gt;No digo que no sea posible hacerlo con streams, solo que después de muchos relíos es más sencillo hacerlo con dos while:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;El primer while que itera sobre todos los elementos proporcionados por StAX.&lt;/li&gt;
  &lt;li&gt;El segundo while empieza cuando se detecta un &lt;em&gt;item&lt;/em&gt; y termina cuando se cierra el &lt;em&gt;item&lt;/em&gt;, leyendo por tanto un post completo.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Con esto en mente es bastante fácil:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
        HashSet&amp;lt;File&amp;gt; exportResult = new HashSet&amp;lt;&amp;gt;();
        XMLEventReader eventReader = getEventReader();
        try {
            exportPosts(exportResult, eventReader);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error reading XML &amp;quot; + origin + &amp;quot;: &amp;quot; + e.getMessage());
        }
        return exportResult;
    }

    private void exportPosts(HashSet&amp;lt;File&amp;gt; exportResult, XMLEventReader eventReader) throws XMLStreamException {
        Post post = null;
        while (eventReader.hasNext()) {
                XMLEvent event = eventReader.nextEvent();
                if (isPostStart(event)) {
                    post = exportPost(exportResult, eventReader, post);
                }
        }
    }

    private Post exportPost(HashSet&amp;lt;File&amp;gt; exportResult, XMLEventReader eventReader, Post post) throws XMLStreamException {
        if (post != null) {
            exportResult.add(mdWriter.write(post));
        }
        post = readPost(eventReader);
        return post;
    }

    private Post readPost(XMLEventReader eventReader) throws XMLStreamException {
        Post exportedPost = new Post();
        boolean postRead = false;
            while (!postRead &amp;amp;&amp;amp; eventReader.hasNext()) {
                XMLEvent event = eventReader.nextEvent();
                if (event.isStartElement()) {
                    exportedPost = loadPostFromEvent(event, eventReader, exportedPost);
                } else if (isPostEnd(event)) {
                    postRead = true;
                }
            }
        return exportedPost;
    }

    private boolean isPostEnd(XMLEvent event) {
        return event.isEndElement() &amp;amp;&amp;amp; &amp;quot;item&amp;quot;.equals(event.asEndElement().getName().getPrefix() + event.asEndElement().getName().getLocalPart());
    }

    private boolean isPostStart(XMLEvent event) {
        return event.isStartElement() &amp;amp;&amp;amp; &amp;quot;item&amp;quot;.equals(getEventFullName(event));
    }

    private Post loadPostFromEvent(XMLEvent event, XMLEventReader eventReader, Post post) {
        String name = getEventFullName(event);
        try {
            switch (name) {
                case &amp;quot;title&amp;quot;:
                    post = loadTitle(eventReader, post);
                    break;
                case &amp;quot;pubDate&amp;quot;:
                    post = loadPublishingDate(eventReader, post);
                    break;
                case &amp;quot;category&amp;quot;:
                    if (isTag(event)) {
                        post = loadCategory(eventReader, event, post);
                    }
                    break;
                case &amp;quot;contentencoded&amp;quot;:
                    post = loadContent(eventReader, post);
                    break;
                default:
                    break;
            }
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error parsing &amp;quot; + name + &amp;quot;: &amp;quot; + e.getMessage());
        }
        return post;
    }

    private Post loadContent(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withContent(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadCategory(XMLEventReader eventReader, XMLEvent event, Post post) throws XMLStreamException {
            return post.withTag(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadPublishingDate(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withPublishingDate(parsePubDate(eventReader));
    }

    private Post loadTitle(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withTitle(eventReader.nextEvent().asCharacters().getData());
    }

    private String getEventFullName(XMLEvent event) {
        return event.asStartElement().getName().getPrefix() + event.asStartElement().getName().getLocalPart();
    }

    private boolean isTag(XMLEvent event) {
        return &amp;quot;post_tag&amp;quot;.equals(event.asStartElement().getAttributeByName(new QName(&amp;quot;domain&amp;quot;)).getValue());
    }


    private Date parsePubDate(XMLEventReader eventReader) throws XMLStreamException {
        Date publishingDate = null;
        try {
            String pubDate = eventReader.nextEvent().asCharacters().getData();
            pubDate = extractDate(pubDate);
            SimpleDateFormat format = new SimpleDateFormat(&amp;quot;dd MMM yyyy&amp;quot;);
            publishingDate = format.parse(pubDate);
        } catch (ParseException e) {
            throw new IllegalStateException(&amp;quot;Could not parse pubDate: &amp;quot; + e.getMessage());
        }
        return publishingDate;
    }

    private String extractDate(String pubDate) {
        //Date is supplied as this: Wed, 30 Nov -0001 00:00:00 +0000, we need to extract just the date
        pubDate = pubDate.substring(pubDate.indexOf(&amp;quot;,&amp;quot;)+2);
        int hourIndex = pubDate.indexOf(&amp;quot;:&amp;quot;)-3;
        pubDate = pubDate.substring(0, hourIndex);
        return pubDate;
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&amp;quot;Could not find origin file: &amp;quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Could not read origin file: &amp;quot; + e.getMessage());
        }
        return eventReader;
    }

    private boolean existsOrigin(String origin) {
        File originFile = new File(origin);
        String path = originFile.getAbsolutePath();
        return originFile.exists();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lo del parseo de la fecha ha sido un espectáculo... no he sido capaz de sacarlo con el DateFormatter para convertirlo a un LocalDate.&lt;br/&gt;Bueno, pues ahora que lo tengo... ¿no tendría más sentido que todo eso fuera a una clase propia? Digamos WpReader. Pues sí, porque ahora mismo mi clase principal se esta responsabilizando de saber como se leen los posts y qué hacer con los posts leidos, así que es mucho más claro hacerlo con una colaboradora.&lt;br/&gt;Pero claro, si me llevo la lógica aparte, ¿cómo aviso de que se puede escribir un nuevo post sin romper el while que itera sobre todos los elementos del XML?&lt;br/&gt;Bueno, pues finamente diría que voy a usar un patrón observador, para notificar de cuando hay un nuevo post. Técnicamente lo que voy a hacer es implementar un callback y así &lt;em&gt;Wp2JBake&lt;/em&gt; queda mucho más clara:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class Wp2JBake {

    private WpReader wpReader;

    private MdWriter mdWriter;

    private HashSet&amp;lt;File&amp;gt; exportResult;

    public Wp2JBake(String origin, String destination) {
        this.wpReader = new WpReader(origin);
        this.mdWriter = new MdWriter(destination);
    }

    public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
        exportResult = new HashSet&amp;lt;&amp;gt;();
        wpReader.readPosts(this);
        return exportResult;
    }

    public void postRead(Post post) {
        exportResult.add(mdWriter.write(post));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y por otro lado tenemos &lt;em&gt;WpReader&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class WpReader {

    public static final String ITEM = &amp;quot;item&amp;quot;;
    public static final String TITLE = &amp;quot;title&amp;quot;;
    public static final String PUB_DATE = &amp;quot;pubDate&amp;quot;;
    public static final String CATEGORY = &amp;quot;category&amp;quot;;
    public static final String CONTENT = &amp;quot;contentencoded&amp;quot;;
    public static final String POST_TAG = &amp;quot;post_tag&amp;quot;;
    public static final String DOMAIN = &amp;quot;domain&amp;quot;;
    private String origin;

    public WpReader(String origin) {
        if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
            throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
        } else {
            this.origin = origin;
        }
    }

    private boolean existsOrigin(String origin) {
        File originFile = new File(origin);
        return originFile.exists();
    }

    public void readPosts(Wp2JBake wp2JBake) {
        XMLEventReader eventReader = getEventReader();
        try {
            readXML(wp2JBake, eventReader);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error reading XML &amp;quot; + origin + &amp;quot;: &amp;quot; + e.getMessage());
        }
    }

    private void readXML(Wp2JBake wp2JBake, XMLEventReader eventReader) throws XMLStreamException {
        while (eventReader.hasNext()) {
            readElement(wp2JBake, eventReader);
        }
    }

    private void readElement(Wp2JBake wp2JBake, XMLEventReader eventReader) throws XMLStreamException {
        XMLEvent event = eventReader.nextEvent();
        if (isPostStart(event)) {
            Post post = readPost(eventReader);
            wp2JBake.postRead(post);
        }
    }

    private Post readPost(XMLEventReader eventReader) throws XMLStreamException {
        Post exportedPost = new Post();
        boolean postRead = false;
        while (!postRead &amp;amp;&amp;amp; eventReader.hasNext()) {
            XMLEvent event = eventReader.nextEvent();
            if (event.isStartElement()) {
                exportedPost = loadAttribute(event, eventReader, exportedPost);
            } else if (isPostEnd(event)) {
                postRead = true;
            }
        }
        return exportedPost;
    }

    private boolean isPostEnd(XMLEvent event) {
        return event.isEndElement() &amp;amp;&amp;amp; ITEM.equals(event.asEndElement().getName().getPrefix() + event.asEndElement().getName().getLocalPart());
    }

    private Post loadAttribute(XMLEvent event, XMLEventReader eventReader, Post post) {
        String name = getEventFullName(event);
        try {
            post = loadAttribute(event, eventReader, post, name);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error parsing &amp;quot; + name + &amp;quot;: &amp;quot; + e.getMessage());
        }
        return post;
    }

    private Post loadAttribute(XMLEvent event, XMLEventReader eventReader, Post post, String name) throws XMLStreamException {
        switch (name) {
            case TITLE:
                post = loadTitle(eventReader, post);
                break;
            case PUB_DATE:
                post = loadPublishingDate(eventReader, post);
                break;
            case CATEGORY:
                if (isTag(event)) {
                    post = loadCategory(eventReader, post);
                }
                break;
            case CONTENT:
                post = loadContent(eventReader, post);
                break;
            default:
                break;
        }
        return post;
    }

    private Post loadContent(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withContent(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadCategory(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withTag(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadPublishingDate(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withPublishingDate(parsePubDate(eventReader));
    }

    private Post loadTitle(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withTitle(eventReader.nextEvent().asCharacters().getData());
    }

    private boolean isTag(XMLEvent event) {
        return POST_TAG.equals(event.asStartElement().getAttributeByName(new QName(DOMAIN)).getValue());
    }


    private Date parsePubDate(XMLEventReader eventReader) throws XMLStreamException {
        Date publishingDate = null;
        try {
            String pubDate = eventReader.nextEvent().asCharacters().getData();
            pubDate = extractDate(pubDate);
            SimpleDateFormat format = new SimpleDateFormat(&amp;quot;dd MMM yyyy&amp;quot;);
            publishingDate = format.parse(pubDate);
        } catch (ParseException e) {
            throw new IllegalStateException(&amp;quot;Could not parse pubDate: &amp;quot; + e.getMessage());
        }
        return publishingDate;
    }

    private String extractDate(String pubDate) {
        //Date is supplied as this: Wed, 30 Nov -0001 00:00:00 +0000 (RFC822 presumably), we need to extract just the date
        pubDate = pubDate.substring(pubDate.indexOf(&amp;quot;,&amp;quot;)+2);
        int hourIndex = pubDate.indexOf(&amp;quot;:&amp;quot;)-3;
        pubDate = pubDate.substring(0, hourIndex);
        return pubDate;
    }

    private boolean isPostStart(XMLEvent event) {
        return event.isStartElement() &amp;amp;&amp;amp; ITEM.equals(getEventFullName(event));
    }

    private String getEventFullName(XMLEvent event) {
        return event.asStartElement().getName().getPrefix() + event.asStartElement().getName().getLocalPart();
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&amp;quot;Could not find origin file: &amp;quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Could not read origin file: &amp;quot; + e.getMessage());
        }
        return eventReader;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pues para terminar con esta sección que se ha alargado más de lo que esperaba, me queda modificar los tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@RunWith(MockitoJUnitRunner.class)
public class WpReaderTest {

    private WpReader sut;

    @Mock
    private Wp2JBake observer;

    @Test(expected = IllegalArgumentException.class)
    public void readerWithoutOrigin() {
        sut = new WpReader(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void readerWithEmptyOrigin() {
        sut = new WpReader(&amp;quot;&amp;quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithInvalidOrigin() {
        sut = new WpReader(&amp;quot;foo&amp;quot;);
    }

    @Test(expected = IllegalStateException.class)
    public void readEmptyXML() {
        sut = new WpReader(&amp;quot;src/test/resources/empty.xml&amp;quot;);
        sut.readPosts(observer);
    }

    @Test(expected = IllegalStateException.class)
    public void readInvalidXML() {
        sut = new WpReader(&amp;quot;src/test/resources/invalid.xml&amp;quot;);
        sut.readPosts(observer);
    }

    @Test
    public void readValidXML() {
        sut = new WpReader(&amp;quot;src/test/resources/wp-source.xml&amp;quot;);
        ArgumentCaptor&amp;lt;Post&amp;gt; postCapturer = ArgumentCaptor.forClass(Post.class);
        sut.readPosts(observer);
        verify(observer, times(7)).postRead(postCapturer.capture());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Con esto ya ha quedado perfecto, si no tanto el software, si los tests. Cada clase tiene una responsabilidad bien definida y así se refleja en los tests. Eso sí, en esta última clase he tenido que meter Mockito para simular el &lt;em&gt;Wp2JBake&lt;/em&gt; que me hace falta para el callback. Lo bueno de esto es que con Mockito puedo verificar las llamadas a los métodos y por primera vez tengo todos los tests en verde.&lt;br/&gt;Eso sí, los tests de &lt;em&gt;Wp2JBake&lt;/em&gt; se han quedado en realidad como pruebas de integración, así que no me preocupa que el test original siga en rojo porque realmente hasta que no este implementada la escritura no debería pasar a verde :).&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Wordpress to JBake - Inicio</title>
      <link>http://www.aguasnegras.es/blog/2016/02/04-wp2jbake-inicio.html</link>
      <pubDate>jue, 4 feb 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/02/04-wp2jbake-inicio.html</guid>
      	<description>
	&lt;p&gt;En la migraci&amp;oacute;n del blog a GitHub Pages uno de los objetivos era no perder contenido, por lo que una vez puesta en pie toda la infraestructura, toca migrar los posts (mucho me temo que los comentarios si se van a perder...). Soluci&amp;oacute;n: Hacer un peque&amp;ntilde;o programa en Java (casi que dir&amp;iacute;a script) que realice autom&amp;aacute;ticamente esta conversi&amp;oacute;n, adem&amp;aacute;s voy a seguir TDD para &quot;mantenerme en forma&quot;.&lt;br/&gt;En un principio lo voy a plantear como una mera conversi&amp;oacute;n de formatos, como formato inicial tengo el que devuelve Wordpress para la exportaci&amp;oacute;n: &lt;a href=&quot;http://devtidbits.com/2011/03/16/the-wordpress-extended-rss-wxr-exportimport-xml-document-format-decoded-and-explained/&quot;&gt;Wordpress Extended RSS&lt;/a&gt; y como formato final quiero un archivo en el formato espec&amp;iacute;fico de JBake, que no deja de ser &lt;a href=&quot;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&quot;&gt;Markdown&lt;/a&gt; con unas cabeceras (metadata) particulares:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;title: El t&amp;iacute;tulo del post&lt;/li&gt;
  &lt;li&gt;date: La fecha del post&lt;/li&gt;
  &lt;li&gt;type: Ser&amp;aacute; siempre post&lt;/li&gt;
  &lt;li&gt;tags: Las etiquetas del post&lt;/li&gt;
  &lt;li&gt;status: Ser&amp;aacute; siempre published&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;El WXR es un solo archivo con una serie de elementos item que corresponde cada uno a un post, un elemento item tiene los siguientes campos interesantes:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;title: casa con la cabecera title que quiero&lt;/li&gt;
  &lt;li&gt;pubdate: casa con la cabecera date&lt;/li&gt;
  &lt;li&gt;category: Las categor&amp;iacute;as se dividen en dominios que puede ser category (bien Wordpress, bien) o post_tag, en concreto me interesan solo aquellas de tipo post_tag y su contenido, es decir tendr&amp;eacute; que concatener el contenido de todas las categor&amp;iacute;as de tipo post_tag.&lt;/li&gt;
  &lt;li&gt;content: Este es el contenido el post en s&amp;iacute;, como se puede ver viene en HTML tal cual dentro de un CDATA, esto me permite aprovechar que con Markdown puedo utilizar el HTML inline as&amp;iacute; que en un principio lo voy a volcar tal cual, aunque preveo ciertos problemas con las etiquetas de c&amp;oacute;digo...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Por &amp;uacute;ltimo, por cada item quiero generar un archivo con el nombre dd-title.md (donde dd es el d&amp;iacute;a de la fecha) dentro de una carpeta mm (mes) dentro de una carpeta aaaa (a&amp;ntilde;o...).&lt;/p&gt;&lt;p&gt;Pues con esto, empezamos!! Primero: crear el projecto en Intellij y con Maven, creo el repositorio en &lt;a href=&quot;https://github.com/agustinventura/wp2jbake&quot;&gt;GitHub&lt;/a&gt; y lo a&amp;ntilde;ado.&lt;br/&gt;A continuaci&amp;oacute;n, actualizo el .gitignore, hago el commit inicial y cambio a la rama development.&lt;/p&gt;&lt;p&gt;El comienzo es un no brainer, necesito un main que arranque la aplicaci&amp;oacute;n como tal y que recibir&amp;aacute; como par&amp;aacute;metros:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;El nombre del archivo WXR&lt;/li&gt;
  &lt;li&gt;El directorio de salida&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Eso quiere decir que la clase de entrada a la aplicaci&amp;oacute;n (Wp2JBake) tendr&amp;aacute; un constructor con dos par&amp;aacute;metros, as&amp;iacute; que siguiendo TDD, empiezo con los tests:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Construir con los par&amp;aacute;metros a null.&lt;/li&gt;
  &lt;li&gt;Construir con el archivo origen a null.&lt;/li&gt;
  &lt;li&gt;Construir con el directorio destino a null.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;En todos estos casos lanzar&amp;eacute; una InvalidArgumentException, as&amp;iacute; que inicialmente tendr&amp;iacute;a como pruebas algo as&amp;iacute;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;private Wp2JBake sut;

@Test(expected = IllegalArgumentException.class)
public void buildWithoutParameters() {
    sut = new Wp2JBake(null, null);
}

@Test(expected = IllegalArgumentException.class)
public void buildWithoutOrigin() {
    sut = new Wp2JBake(null, &amp;quot;&amp;quot;);
}

@Test(expected = IllegalArgumentException.class)
public void buildWithoutDestination() {
    sut = new Wp2JBake(&amp;quot;&amp;quot;, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y como implementaci&amp;oacute;n lo siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (origin == null) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (destination == null) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pero... un segundo, &amp;iquest;me d&amp;aacute; igual la IllegalArgumentException que se lanza? No, en cada caso quiero verificar que se esta lanzando la que se debe, refactorizo las pruebas, ahora voy a utilizar un @Rule de JUnit para comprobar que se lanza la excepci&amp;oacute;n y el mensaje de error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Rule
public ExpectedException thrown = ExpectedException.none();

private Wp2JBake sut;

@Test
public void buildWithoutParameters() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(null, null);
}

@Test
public void buildWithoutOrigin() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(null, &amp;quot;foo&amp;quot;);

}

@Test
public void buildWithoutDestination() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;foo&amp;quot;, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Vale, ya he controlado que no sea null, ahora toca comprobar que tampoco sea cadena vac&amp;iacute;a:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt; @Test
public void buildWithEmptyOrigin() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;);
}

@Test
public void buildWithEmptyDestination() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora toca cambiar la implementaci&amp;oacute;n, me voy a apoyar en las commons-lang:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (StringUtils.isEmpty(destination)) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Siguiente restricci&amp;oacute;n, el origen adem&amp;aacute;s debe existir:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void buildWithInvalidOrigin() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y la implementaci&amp;oacute;n:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (StringUtils.isEmpty(destination)) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}

private boolean existsOrigin(String origin) {
    File originFile = new File(origin);
    return originFile.exists();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Esta implementaci&amp;oacute;n hace saltar las pruebas de origen inv&amp;aacute;lido, claro como para &quot;callar&quot; los tests estoy pasando como primer par&amp;aacute;metro una cadena cualquiera, ahora falla porque no existe el par&amp;aacute;metro foo.&lt;br/&gt;Aqu&amp;iacute; hay dos opciones:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Pasar un archivo que si exista.&lt;/li&gt;
  &lt;li&gt;Cambiar la implementaci&amp;oacute;n para que primero compruebe que la cadena es v&amp;aacute;lida en los dos casos y despu&amp;eacute;s que compruebe si el archivo es v&amp;aacute;lido.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;El problema de 2 es que tendr&amp;iacute;a que lanzar la misma excepci&amp;oacute;n dos veces mientras que el de 1 es que se parecer&amp;iacute;a m&amp;aacute;s a un test de integraci&amp;oacute;n que a una prueba unitaria en s&amp;iacute;. Para mi gusto esta es una de las zonas grises en TDD, porque, &amp;iquest;ahora qu&amp;eacute; hago?&amp;iquest;Creo un mock del SUT? No lo veo claro,&lt;br/&gt;as&amp;iacute; que tratar&amp;eacute; de tirar por el camino del medio y pasar una ruta de archivo que sepa que siempre existe, por ejemplo, el pom.xml.&lt;/p&gt;&lt;p&gt;Ahora podr&amp;iacute;a seguir comprobando que el destino no sea inv&amp;aacute;lido, pero... &amp;iquest;puede serlo? Al ser un directorio, si no existe, deber&amp;iacute;a crearlo y si existe, no hacer nada. En todo caso la comprobaci&amp;oacute;n deber&amp;iacute;a ser si se puede crear el directorio y si se puede escribir en &amp;eacute;l.&lt;/p&gt;&lt;p&gt;De aqu&amp;iacute; saco estas dos pruebas:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void buildWithNonWritableDestination() {
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.mkdir();
    destination.deleteOnExit();
    destination.setReadOnly();
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;pom.xml&amp;quot;, destination.getAbsolutePath());
}

@Test
public void buildWithNonWritableDestinationParent() {
    File destinationParent = new File(&amp;quot;destinationParent&amp;quot;);
    destinationParent.mkdir();
    destinationParent.deleteOnExit();
    destinationParent.setReadOnly();
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;pom.xml&amp;quot;, destinationParent.getAbsolutePath() + File.separator + &amp;quot;destination&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y la implementaci&amp;oacute;n sigue creciento:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (StringUtils.isEmpty(destination) || !isWritable(destination)) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}

private boolean isWritable(String destination) {
    File destinationFolder = new File(destination);
    if (destinationFolder.exists()) {
        return destinationFolder.canWrite();
    } else {
        return destinationFolder.getParentFile().canWrite();
    }
}

private boolean existsOrigin(String origin) {
    File originFile = new File(origin);
    String path = originFile.getAbsolutePath();
    return originFile.exists();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por &amp;uacute;ltimo me quedar&amp;iacute;a probar el caso en el que ambos par&amp;aacute;metros son v&amp;aacute;lidos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void buildWithValidParameters() {
    sut = new Wp2JBake(&amp;quot;pom.xml&amp;quot;, &amp;quot;destination&amp;quot;);
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.delete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Con esto puedo empezar a refactorizar y a remplatearme las cosas. La verdad que Wp2JBake empieza a tener un tama&amp;ntilde;o considerable teniendo en cuenta que tan s&amp;oacute;lo tiene como API un constructor. La verdad que las comprobaciones que estoy haciendo sobre los par&amp;aacute;metros no me convencen, me dan la impresi&amp;oacute;n de que estoy violando el Single Responsability, por otra parte ser&amp;iacute;a un poco artificial crear una clase de validadores &amp;uacute;nicamente.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Migrando el blog</title>
      <link>http://www.aguasnegras.es/blog/2016/01/03-migracion.html</link>
      <pubDate>dom, 3 ene 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/01/03-migracion.html</guid>
      	<description>
	&lt;p&gt;Desde hace ya bastantes años llevo pagando religiosamente todos los años un dominio (aguasnegras.es) y un alojamiento para tener el blog.&lt;br/&gt;El blog ha tenido mejores y peores momentos, pero en general me gusta tener un sitio donde poder escribir en un momento dado, y por supuesto compartir con la comunidad (sobre todo en español, es por lo que escribo en este idioma).&lt;/p&gt;&lt;p&gt;El asunto es que si nos paramos a pensarlo, el blog tiene bastantes pocos comentarios y sobre todo entradas mías, es decir, es fundamentalmente un medio de solo lectura. Hace ya un tiempo que pienso que tener para ésto un Wordpress con su PHP y su MySQL es bastante asesino y hasta antieconómico (en sentido general, porque el hosting me cuesta cuatro duros al año, tampoco vamos a ser ruinas). Otra cosa que me molesta bastante es tener que andar actualizando Wordpress (cosa lógica y normal) y aunque ya las actualizaciones sean automáticas, pues me molesta.&lt;/p&gt;&lt;p&gt;Total, que a esto le sumamos que GitHub ofrece desde hace tiempo &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; que consiste en alojamiento gratuito para HTML estático y más a huevo imposible... quedaría pendiente el tema de los comentarios, pero precisamente para esto, &lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt; permite incluirlos por Javascript con una configuración muy sencilla.&lt;/p&gt;&lt;p&gt;Con esto ya va quedando claro el enfoque, ahora habría que ver como generar el HTML, ya que escribir HTML a pelo es posible, pero es más bien coñazo. GitHub Pages usa &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; que permite usar Markdown para escribir, pero como buen javero de pro he buscado una opción similar en Java, &lt;a href=&quot;http://jbake.org/&quot;&gt;JBake&lt;/a&gt;. Eso sí, el inconveniente es claro, con Jekyll lo único que hay que subir a GitHub son los archivos .md mientras que con JBake tendré que generar el HTML y subirlo.&lt;/p&gt;&lt;p&gt;Por tanto, hay tres trabajos importantes que hacer para estudiar la viabilidad de usar GitHub Pages para alojar el blog:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Integrar Disqus en JBake.&lt;/li&gt;
  &lt;li&gt;Personalizar el HTML generado por JBake.&lt;/li&gt;
  &lt;li&gt;Ver como subir los fuentes y HTML a GitHub y estudiar el workflow de publicación.&lt;/li&gt;
&lt;/ol&gt;
	</description>
    </item>
    <item>
      <title>Logging en Java con SLF4J y Log4j2</title>
      <link>http://www.aguasnegras.es/blog/2013/8/2-Logging en Java con SLF4J y Log4j2.html</link>
      <pubDate>lun, 2 sep 2013 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2013/8/2-Logging en Java con SLF4J y Log4j2.html</guid>
      	<description>
	&lt;p&gt;En este artículo se hace una breve introducción a la generación de logs en Java usando SLF4J y Log4j2, así como un breve repaso de las mejores prácticas relativas.&lt;/p&gt;
&lt;h5&gt;Introducción&lt;/h5&gt;&lt;p&gt;En Java se da una circunstancia muy extraña, siendo el logging tan importante como es, no hay una buena solución integrada en el framework como tal. Es cierto que existe la &lt;a title=&quot;Java Logging Framework en Wikipedia&quot; href=&quot;http://en.wikipedia.org/wiki/Java_logging_framework&quot; target=&quot;_blank&quot;&gt;Java Logging API o Java Logging Framework&lt;/a&gt;, pero fue una adición bastante a posteriori (en concreto, se añadió en el 2002, en la versión 1.4 del JDK). Para cuando esta API salió como parte del JDK ya teníamos un &quot;estándar&quot; de facto, &lt;a title=&quot;Log4j 1.2&quot; href=&quot;http://logging.apache.org/log4j/1.2/&quot; target=&quot;_blank&quot;&gt;Log4j&lt;/a&gt;, que fue creado en el 1999. Mientras tanto, y haciendo honor a aquella vieja &lt;a title=&quot;XKCD - Standards&quot; href=&quot;http://xkcd.com/927/&quot; target=&quot;_blank&quot;&gt;tira de XKCD&lt;/a&gt;, seguían saliendo frameworks de loggings: &lt;a title=&quot;Logback&quot; href=&quot;http://logback.qos.ch/&quot; target=&quot;_blank&quot;&gt;logback&lt;/a&gt;, &lt;a title=&quot;commons-logging&quot; href=&quot;http://commons.apache.org/proper/commons-logging/&quot; target=&quot;_blank&quot;&gt;commons-logging&lt;/a&gt;, &lt;a title=&quot;SLF4J&quot; href=&quot;http://www.slf4j.org/&quot; target=&quot;_blank&quot;&gt;slf4j&lt;/a&gt; y otros tipos de soluciones a cada cual más exótica. En &lt;a title=&quot;The Logging Mess&quot; href=&quot;http://techblog.bozho.net/?p=503&quot; target=&quot;_blank&quot;&gt;este artículo&lt;/a&gt; se hace un repaso bastante completo de la historia del desaguisado.&lt;br/&gt;A verano de 2013, la  situación no ha mejorado, tal y como recoge una reciente &lt;a title=&quot;State of Logging in Java 2013&quot; href=&quot;http://zeroturnaround.com/rebellabs/the-state-of-logging-in-java-2013/&quot; target=&quot;_blank&quot;&gt;encuesta de ZeroTurnAround&lt;/a&gt;. Si acaso se clarifican dos tendencias:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;En general, se suele usar una fachada de abstracción sobre el sistema de logs como puede ser SLF4J o commons-logging. Entiendo que ésto es debido a que muchas organizaciones imponen el uso de un framework de logging en concreto y mediante esta indirección ganas flexibilidad.&lt;/li&gt;
	&lt;li&gt;Log4J sigue siendo 14 años después el framework de logging más usado. Si eso no es un estándar de facto...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Por tanto, parece razonable aplicar la filosofía de fachada de logging + framework de logging para el desarrollo de un nuevo producto. En cuanto a fachada de logging se usará SLF4J y como framework de logging se explicará el uso de Log4j2. ¿Por qué el 2 y no el 1? Pues básicamente por velocidad. El logging es una actividad que realmente es accesoria, por tanto no debería consumir recursos del sistema apenas, la página de Log4j2 explica que esta es una de las motivaciones tras la versión 2 del framework, y &lt;a title=&quot;Log4j2 Performance close to insane&quot; href=&quot;http://www.grobmeier.de/log4j-2-performance-close-to-insane-20072013.html#.UiMaLt9wB2N&quot; target=&quot;_blank&quot;&gt;este artículo&lt;/a&gt; confirma su velocidad. Sin embargo hay que tener en cuenta que Log4j2 esta actualmente en beta 8, pero dado que vamos a usar SLF4J se puede sustituir por su versión 1 o por logback o como se desee.&lt;br/&gt;Otro aspecto a considerar a la hora de usar la versión 2 de log4j es que cuando se usa Maven, el log4j 1.2.x incluye varias dependencias que lo más normal es que no se usen, como javax.mail, geronimo-jms, etc...&lt;/p&gt;
&lt;h5&gt;Configuración&lt;/h5&gt;&lt;p&gt;La configuración en un proyecto con Maven es tan sencilla como añadir las siguientes dependencias al pom.xml:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&lt;br/&gt;&amp;lt;!-- slf4j --&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- log4j2 --&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;log4j-api&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.0-beta8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.0-beta8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;log4j-slf4j-impl&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;2.0-beta8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;La primera dependencia es la api de SLF4J, que realmente es la que se utilizará en la aplicación para escribir los mensajes de log. A continuación esta la API y el Core de Log4j2 y por último el puente entre SLF4J y Log4j2. Ya que SLF4J es una fachada de logging, el proyecto incluye varios puentes para trabajar con los frameworks más comunes, sin embargo, como Log4j2 es un proyecto nuevo, es éste el que incluye el puente para SLF4J.&lt;/p&gt;
&lt;h5&gt;Uso&lt;/h5&gt;&lt;p&gt;El uso de SLF4J es bastante sencillo, basta con instanciar el objeto de logging, el logger:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;private static Logger logger = LoggerFactory.getLogger(Logging.class);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Esta variable es privada para evitar que otras clases puedan usarla, porque en ese caso parecería que el error se ha producido en nuestra clase Logging, además es static para que tan solo haya una instancia del logger sin importar las instancias que haya de la clase (es decir, es singleton). Se puede usar también una instancia normal, cada aproximación tiene sus pros y sus contras como se discute &lt;a title=&quot;Static vs. Instance loggers&quot; href=&quot;http://www.slf4j.org/faq.html#declared_static&quot;&gt;aquí&lt;/a&gt;.&lt;br/&gt;En cuanto al uso del logger es muy sencillo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;public static void main (String... args) {
	logger.info(&amp;quot;Starting application&amp;quot;);
	logger.debug(&amp;quot;Loading Lannister house&amp;quot;);
	House lannister = new House(&amp;quot;Lannister&amp;quot;);
	logger.debug(&amp;quot;Invoking Clegane bannerman&amp;quot;);
	lannister.invokeBannerMan(&amp;quot;Clegane&amp;quot;);
	logger.debug(&amp;quot;Invoking erroneous bannerman&amp;quot;);
	lannister.invokeBannerMan(null);
	logger.info(&amp;quot;Ended application&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;En este ejemplo, se crea una Casa llamada Lannister y se invoca a dos banderizos, uno llamado Clegane y otroal que por error se pasa null como nombre.&lt;br/&gt;El resultado de ejecutar este programa es el siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;14:21:23.629 [main] ERROR es.aguasnegras.logging.model.House - Error loading house Lannister bannerman: bannerman name can&amp;#39;t be empty
Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalStateException: Cant invoke bannerman without name
	at es.aguasnegras.logging.model.House.invokeBannerMan(House.java:44)
	at es.aguasnegras.logging.Logging.main(Logging.java:20)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;La ejecución de la aplicación falla al invocar el banderizo con null (normal)&lt;br/&gt;Como se ve la invocación al logger es en todo caso la misma, variando solo según el nivel de importancia del mensaje de error. En total en SLF4J vienen definidos los siguientes niveles de log:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt; Error: Ocurrió un error en la aplicación.&lt;/li&gt;
	&lt;li&gt;Warn: Se ha dado una circunstancia de posible error.&lt;/li&gt;
	&lt;li&gt;Info: Información sobre la ejecución de la aplicación.&lt;/li&gt;
	&lt;li&gt;Debug: Información importante para debuggear la aplicación.&lt;/li&gt;
	&lt;li&gt;Trace: Información de traza sobre la ejecución de la aplicación.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;En otros frameworks existe un nivel adicional de log: Fatal, pero SLF4J no lo recoge, he &lt;a title=&quot;SLF4J y nivel de log Fatal&quot; href=&quot;http://www.slf4j.org/faq.html#fatal&quot;&gt;aquí&lt;/a&gt; la explicación. Yo personalmente creo que puedo vivir sin ello.&lt;br/&gt;El objeto de cualquier framework de logging es que podamos configurar fácilmente cuales de estos mensajes se mostrarán según el entorno. Lo más normal es que en desarrollo deseemos mostrar los mensajes de debug y superiores, mientras que en producción se establezca el nivel a info (o incluso a error). Ahora bien, si hay un error en producción, lo más interesante es ajustar directamente el nivel de log a trace y así dispondríamos de toda la información relevante.&lt;br/&gt;Sin embargo, en el ejemplo pese a tener invocaciones a debug, a info y a trace, tan solo sale el mensaje relativo al error (que además se registra en la clase House). Esto es porque aún no hemos definido la configuración de los mensajes de log y por defecto log4j2 tan solo recoge los mensajes con nivel Error.&lt;br/&gt;&lt;h5&gt;Configuración de Log4j2&lt;/h5&gt;&lt;br/&gt;En primer lugar, hay que decir que la configuración de log4j2 se realiza bien mediante un archivo xml, bien mediante un archivo json. En log4j 1.2 se podía configurar también mediante un archivo .properties, como a mí nunca me gustó esa opción (la veía confusa), agradezco que la hayan quitado.&lt;br/&gt;Lo primero es crear en main/resources un fichero log4j2.xml (tal y como se explica &lt;a title=&quot;Configuración de Log4j2&quot; href=&quot;http://logging.apache.org/log4j/2.x/manual/configuration.html#AutomaticConfiguration&quot;&gt;aquí&lt;/a&gt;), una vez creado, se completa tal que así:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&lt;br/&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration status=&amp;quot;WARN&amp;quot;&amp;gt;
  &amp;lt;appenders&amp;gt;
    &amp;lt;Console name=&amp;quot;Console&amp;quot; target=&amp;quot;SYSTEM_OUT&amp;quot;&amp;gt;
      &amp;lt;PatternLayout pattern=&amp;quot;%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&amp;quot;/&amp;gt;
    &amp;lt;/Console&amp;gt;
  &amp;lt;/appenders&amp;gt;
  &amp;lt;loggers&amp;gt;
    &amp;lt;root level=&amp;quot;trace&amp;quot;&amp;gt;
      &amp;lt;appender-ref ref=&amp;quot;Console&amp;quot;/&amp;gt;
    &amp;lt;/root&amp;gt;
  &amp;lt;/loggers&amp;gt;
&amp;lt;/configuration&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;El archivo empieza con el elemento &lt;em&gt;configuration&lt;/em&gt; que tiene un atributo &lt;em&gt;status&lt;/em&gt;, ese atributo significa el nivel de log de error que quiero aplicar al mismo log4j, a warn esta bien.&lt;br/&gt;A continuación defino un &lt;em&gt;appender&lt;/em&gt;. Se puede pensar un appender es un destino de los mensajes de log, se puede tener un appender para presentar por consola, otro para guardar en archivo, otro para enviar por email o combinación de todos los anteriores. &lt;a title=&quot;Appenders de Log4j2&quot; href=&quot;http://logging.apache.org/log4j/2.x/manual/layouts.html&quot;&gt;Aquí&lt;/a&gt; se pueden consultar todos los appenders que hay.&lt;br/&gt;A su vez un appender tiene un &lt;em&gt;layout&lt;/em&gt; que no es más que la forma de darle formato al mensaje de log: bien siguiendo un patrón, bien en html, etc... de nuevo hay una extensa &lt;a title=&quot;Appenders de Log4j2&quot; href=&quot;http://logging.apache.org/log4j/2.x/manual/layouts.html&quot;&gt;lista&lt;/a&gt;.&lt;br/&gt;Y por último estan los &lt;em&gt;logger&lt;/em&gt; como tal. Los loggers tienen una particularidad, y es que existe un logger &quot;padre&quot; del que heredan todos los existentes: root, después de él se podrán crear los que sean oportunos, pero al menos siempre existirá root. Un logger tiene un nivel (que es el nivel mínimo de log cuyos mensajes se mostrarán) y una lista de appenders que se utilizarán para mostrar los mensajes.&lt;br/&gt;De momento solo tengo configurado root y con nivel &lt;em&gt;trace&lt;/em&gt; con lo que se mostrarán todos los mensajes que se generen. Tal que así:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&lt;br/&gt;17:02:03.721 [main] INFO  es.aguasnegras.logging.Logging - Starting application
17:02:03.723 [main] DEBUG es.aguasnegras.logging.Logging - Loading Lannister house
17:02:03.742 [main] TRACE es.aguasnegras.logging.model.House - Loaded house Lannister without bannermen
17:02:03.742 [main] DEBUG es.aguasnegras.logging.Logging - Invoking Clegane bannerman
17:02:03.763 [main] TRACE es.aguasnegras.logging.model.BannerMan - Loaded bannerman Clegane with house Lannister
17:02:03.763 [main] TRACE es.aguasnegras.logging.model.House - Adding bannerman Clegane to house Lannister
17:02:03.763 [main] DEBUG es.aguasnegras.logging.Logging - Invoking erroneous bannerman
17:02:03.763 [main] ERROR es.aguasnegras.logging.model.House - Error loading house Lannister bannerman: bannerman name can&amp;#39;t be empty
Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalStateException: Cant invoke bannerman without name
	at es.aguasnegras.logging.model.House.invokeBannerMan(House.java:44)
	at es.aguasnegras.logging.Logging.main(Logging.java:20)

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y ahora se puede empezar a modificar la configuración. Por ejemplo, si quiero que aparezcan todos los mensajes de error para Logging pero para las demás clases que solo aparezcan de info para arriba, puedo añadir este logger a la configuración:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&lt;br/&gt;&amp;lt;loggers&amp;gt;
	&amp;lt;root level=&amp;quot;trace&amp;quot;&amp;gt;
		&amp;lt;appender-ref ref=&amp;quot;Console&amp;quot; /&amp;gt;
	&amp;lt;/root&amp;gt;
	&amp;lt;logger name=&amp;quot;es.aguasnegras.logging.model&amp;quot; level=&amp;quot;info&amp;quot; additivity=&amp;quot;false&amp;quot;&amp;gt;
		&amp;lt;appender-ref ref=&amp;quot;Console&amp;quot; /&amp;gt;
	&amp;lt;/logger&amp;gt;
&amp;lt;/loggers&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Estoy creando un logger nuevo para el paquete &lt;em&gt;es.aguasnegras.logging.model&lt;/em&gt; que recogerá todos los mensajes de información y los mostrará por el appender &lt;em&gt;Console&lt;/em&gt;. El atributo &lt;em&gt;additivity&lt;/em&gt; a false indica que los mensajes que se muestren por este logger no se deberán mostrar por root (si no, saldrían duplicados).&lt;br/&gt;Es importante tener en cuenta que el nivel de log de root es el mínimo para todo el sistema. Es decir, si yo arriba cambio el nivel de root por &lt;em&gt;error&lt;/em&gt; y el de model por &lt;em&gt;trace&lt;/em&gt; tan solo se mostrarán los mensajes de error, ya que el resto no se evaluarán.&lt;br/&gt;Si por ejemplo ahora quisiera que si se mostraran todos los mensajes de log de la clase BannerMan, podría hacer así:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&lt;br/&gt;&amp;lt;root level=&amp;quot;trace&amp;quot;&amp;gt;
	&amp;lt;appender-ref ref=&amp;quot;Console&amp;quot; /&amp;gt;
&amp;lt;/root&amp;gt;
&amp;lt;logger name=&amp;quot;es.aguasnegras.logging.model&amp;quot; level=&amp;quot;info&amp;quot; additivity=&amp;quot;false&amp;quot;&amp;gt;
	&amp;lt;appender-ref ref=&amp;quot;Console&amp;quot; /&amp;gt;
&amp;lt;/logger&amp;gt;
&amp;lt;logger name=&amp;quot;es.aguasnegras.logging.model.BannerMan&amp;quot; level=&amp;quot;trace&amp;quot; additivity=&amp;quot;false&amp;quot;&amp;gt;
	&amp;lt;appender-ref ref=&amp;quot;Console&amp;quot; /&amp;gt;
&amp;lt;/logger&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y así, sucesivamente. Aquí, por mantener el ejemplo sencillo, solo he utilizado un appender, pero cada logger podría usar un appender distinto, por ejemplo, root podría utilizar la consola, pero model podría usar un archivo.&lt;/p&gt;
&lt;h5&gt;Uso Eficiente de la API&lt;/h5&gt;&lt;p&gt;Arriba comentaba que un framework de logging, sobre todo ha de ser rápido y no consumir ciclos de CPU, ni memoria, etc... En general, para evitar el consumo &quot;tonto&quot; de recursos en muchos sitios recomiendan hacer lo siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&lt;br/&gt;if (logger.isTraceEnabled()) {
	logger.trace(&amp;quot;Adding bannerman &amp;quot; + bannerManName + &amp;quot; to house &amp;quot; + name);
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Este código, desde mi punto de vista tiene varios inconvenientes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;En el caso mejor (trace no esta habilitado), se ejecuta una instrucción&lt;/li&gt;
&lt;li&gt;En el caso peor (trace esta habilitado), se ejecutan dos instrucciones y además se construye la cadena con el mensaje&lt;/li&gt;
&lt;li&gt;Además, para cumplir con DRY, nos veremos tentados de crear una fachada de logging sobre la fachada de logging (WTF!)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Para evitar todo esto, en SLF4J &lt;a title=&quot;Forma más rápida de logar&quot; href=&quot;http://www.slf4j.org/faq.html#logging_performance&quot;&gt;recomiendan esta forma de logar&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;&lt;br/&gt;logger.trace(&amp;quot;Adding bannerman {} to house {}&amp;quot;, bannerManName, name);

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Así de sencillo y de fácil. Por supuesto el método acepta múltiples parámetros y si se pasa un objeto se invoca el toString.&lt;/p&gt;
&lt;h5&gt;Código&lt;/h5&gt;&lt;p&gt;Pues con esto se acaba este pequeño repaso de lo fundamental sobre SLF4J y Log4j2, el código, en github (para variar).&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/agustinventura/logging&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>JUnit 4 y DataSources</title>
      <link>http://www.aguasnegras.es/blog/2010/10/20-JUnit 4 y DataSources.html</link>
      <pubDate>sáb, 20 nov 2010 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2010/10/20-JUnit 4 y DataSources.html</guid>
      	<description>
	&lt;p&gt;Cuando desarrollo aplicaciones web (y tengo tiempo) me gusta seguir una variante propia de &lt;a title=&quot;Test Driven Development&quot; href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot; target=&quot;_blank&quot;&gt;TDD&lt;/a&gt;. Básicamente trato de ser exhaustivo con las pruebas y en este sentido JUnit es lo suyo, diseño el DAO y le hago pruebas unitarias, diseño la capa de servicios y le hago pruebas unitarias, es más, si tengo tiempo hago pruebas unitarias sobre las mismas entidades.&lt;/p&gt;&lt;p&gt;A las malas malas, JUnit me sirve para probar la funcionalidad de la aplicación antes de hacer la interfaz de usuario.&lt;/p&gt;&lt;p&gt;Últimamente trabajo siempre con Spring o JPA, por lo que los accesos a base de datos son a través de un DataSource, bien gestionado por Spring, bien gestionado por JPA.&lt;/p&gt;&lt;p&gt;El caso es que para las pruebas en general, en vez de andar creando las conexiones a base de datos aparte y pasarlas a los DAO, mola crear un DataSource y publicarlo por JNDI, así nunca hay que volver a tocar nada.&lt;/p&gt;&lt;p&gt;Tras investigar algo me encuentro que esto no es algo que este muy trillado, así que nada, manos a la obra. Lo que hago es definir un método @BeforeClass para que me cree el DataSource y me lo publique en el contexto JNDI antes de que se ejecute ninguna prueba.&lt;/p&gt;&lt;p&gt;El código es bastante sencillo y autoexplicativo, para que funcione, es necesario el naming-commons.jar, naming-factory.jar y el naming-resources.jar, se encuentra normalmente en cualquier tomcat en $CATALINA_HOME/common/lib.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;public class DataBaseTest {

	@BeforeClass
	public static void setDataSource() {
		try {
			// Create initial context
			System.setProperty(Context.INITIAL_CONTEXT_FACTORY,
					&amp;quot;org.apache.naming.java.javaURLContextFactory&amp;quot;);
			System.setProperty(Context.URL_PKG_PREFIXES, &amp;quot;org.apache.naming&amp;quot;);
			InitialContext ic = new InitialContext();
			ic.createSubcontext(&amp;quot;jdbc&amp;quot;);

			// Construct DataSource
			OracleConnectionPoolDataSource ds = new OracleConnectionPoolDataSource();
			ds.setURL(&amp;quot;jdbc:oracle:thin:@server:port:SID&amp;quot;);
			ds.setUser(&amp;quot;user&amp;quot;);
			ds.setPassword(&amp;quot;password&amp;quot;);

			ic.bind(&amp;quot;jdbc/ds&amp;quot;, ds);
		} catch (NamingException ex) {
			Logger.getLogger(DataBaseTest.class.getName()).log(
					Level.SEVERE, null, ex);
		} catch (SQLException e) {
			Logger.getLogger(DataBaseTest.class.getName()).log(
					Level.SEVERE, null, e);
		}
	}

	public DataBaseTest() {
		super();
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y eso es todo, para usar exactamente esta implementación también es conveniente tener log4j y el ojdbc14.jar.&lt;/p&gt;&lt;p&gt;Referencias:&lt;br/&gt;&lt;ol&gt;&lt;br/&gt; &lt;li&gt;&lt;a href=&quot;http://blogs.sun.com/randystuph/entry/injecting_jndi_datasources_for_junit&quot;&gt;&lt;a href=&quot;http://blogs.sun.com/randystuph/entry/injecting_jndi_datasources_for_junit&quot;&gt;http://blogs.sun.com/randystuph/entry/injecting_jndi_datasources_for_junit&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;&lt;br/&gt; &lt;li&gt;&lt;a href=&quot;http://www.coderanch.com/howto/java/CodeBarnLibrariesAndFrameworks&quot;&gt;&lt;a href=&quot;http://www.coderanch.com/how-to/java/CodeBarnLibrariesAndFrameworks&quot;&gt;http://www.coderanch.com/how-to/java/CodeBarnLibrariesAndFrameworks&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;&lt;br/&gt;&lt;/ol&gt;&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Aprendiendo Ruby on Rails</title>
      <link>http://www.aguasnegras.es/blog/2010/10/13-Aprendiendo Ruby on Rails.html</link>
      <pubDate>sáb, 13 nov 2010 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2010/10/13-Aprendiendo Ruby on Rails.html</guid>
      	<description>
	&lt;p&gt;En mi trabajo, uno de los proyectos en los que ando metido es la estandarización de proyectos de desarrollo Java en entorno web, a todos los niveles.&lt;/p&gt;&lt;p&gt;A priori esto parece muy fácil y un trabajo bonito, pero el asunto se complica mucho cuando te das cuenta de la amplitud del trabajo:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Definición de herramientas a usar (IDE, gestor de versiones, herramienta de construcción...)&lt;/li&gt;
	&lt;li&gt;Definición de framework de desarrollo (framework MVC, framework ORM, framework IoC...)&lt;/li&gt;
	&lt;li&gt;Definición de estándares de código&lt;/li&gt;
	&lt;li&gt;Formación del personal&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Con ésto no quiero decir que el desarrollo en Java sea demasiado complicado, más bien al revés, el entorno es tan flexible que puedes hacer auténticas maravillas y habitualmente encontrar múltiples soluciones al mismo problema, así que si no puedes aplicar una, te resultará muy sencillo aplicar la otra.&lt;/p&gt;&lt;p&gt;Sin embargo, esto resulta ser muchas veces un engorro, ya que a veces el entorno es demasiado &quot;difuso&quot;, dicho de otra manera, se echa de menos tener un entorno de estudio más cerrado en el cual convertirte en un experto (en Java, es muy posible que seas un experto en JPA, pero no en Hibernate... y viceversa, pero claro, ¿para qué lo vas a ser cuando ambas tecnologías sirven para lo mismo?).&lt;/p&gt;&lt;p&gt;Así que he decidido aprender algo nuevo, y después de curiosear y mirar por ahí he decidido darle una oportunidad a Ruby on Rails e ir posteando por aquí mis experiencias.&lt;/p&gt;&lt;p&gt;El tutorial que voy a seguir es este: &lt;a title=&quot;railstutorial.org&quot; href=&quot;http://railstutorial.org/book&quot; target=&quot;_blank&quot;&gt;railstutorial.org&lt;/a&gt;&lt;/p&gt;&lt;p&gt;No voy a entrar en detalles de por qué Ruby on Rails y no PHP ya que no pretendo que sea una comparativa exhaustiva, sencillamente me ha dado por ahí y ya esta :)&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Entorno de Ruby on Rails - Parte 1</title>
      <link>http://www.aguasnegras.es/blog/2010/10/13-Entorno de Ruby on Rails - Parte 1.html</link>
      <pubDate>sáb, 13 nov 2010 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2010/10/13-Entorno de Ruby on Rails - Parte 1.html</guid>
      	<description>
	&lt;p&gt;Para seguir el tutorial voy a usar mi viejo buen portátil (tiene ya 6 años), con una Ubuntu 10.04 y el siguiente stack de desarrollo (siguiendo lo recomendado en el tutorial):&lt;br/&gt;&lt;ul&gt;&lt;br/&gt; &lt;li&gt;Editor: gVim (y las extensiones de ruby de vim)&lt;/li&gt;&lt;br/&gt; &lt;li&gt;Control de versiones: git (apt-get install git-core)&lt;/li&gt;&lt;br/&gt; &lt;li&gt;Ruby versión 1.8.7&lt;/li&gt;&lt;br/&gt;&lt;/ul&gt;&lt;br/&gt;Y hasta aquí todo bien, no deja de ser todo apt-get install, ahora el tutorial recomienda instalar &lt;a title=&quot;Ruby Version Management&quot; href=&quot;http://rvm.beginrescueend.com/&quot; target=&quot;_blank&quot;&gt;RVM (Ruby Version Management)&lt;/a&gt;, un gestor de versiones de Ruby. El tema me suena, haciendo un símil con Java, yo puedo estar desarrollando con Java 1.6 pero querer compilar con Java 1.5 (por cuestión de compatibilidad o cualquier motivo), al parecer Ruby tiene una herramienta que gestiona este tipo de cosas... la verdad, tiene buena pinta, vamos a ver.&lt;/p&gt;&lt;p&gt;La instalación es con git (primera toma de contacto):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;bash &amp;amp;lt; &amp;amp;lt;( curl http://rvm.beginrescueend.com/releases/rvm-install-head )
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;se ejecuta sin problemas y sale un bonito texto dando información varia. Básicamente y según la sección &quot;Postinstall&quot; de la misma página de rvm, hay que añadir una línea al final del .bashrc:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;[[ -s &amp;quot;$HOME/.rvm/scripts/rvm&amp;quot; ]] &amp;amp;amp;&amp;amp;amp; . &amp;quot;$HOME/.rvm/scripts/rvm&amp;quot;  # This loads RVM into a shell session
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Se comprueba si esta funcionando con:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;type rvm | head -n1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Salida, correcta, así que seguimos y nos volvemos al tutorial donde dicen como usar RVM una vez instalado.&lt;/p&gt;&lt;p&gt;Básicamente, según estoy entendiendo, Ruby se distribuye en Gems, que son programas autosuficientes con sus librerías, etc... y con RVM vamos a instalar varios perfiles de ejecución incluyendo sus Gems y vamos a definir uno por defecto.&lt;/p&gt;&lt;p&gt;Asi que nada:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;rvm install 1.8.7 #instala Ruby 1.8.7
rvm install 1.9.2 #instala Ruby 1.9.2
#etiquetamos lo perfiles
rvm --create 1.8.7@rails2
rvm --create 1.9.2@rails3
#usamos rails3 por defecto
rvm --default use 1.9.2@rails3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por cierto, la compilación de la versiones de Ruby... tarda. O será que mi portátil esta ya bien viejuno.&lt;/p&gt;&lt;p&gt;Una vez hechas todas estas operaciones, me llevo la grata sorpresa de que de propina tenemos instalado RubyGems, un gestor de paquetes de Ruby, para probarlo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;which gem
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Trato de actualizar tal y como dice el manual:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;gem update --system
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y... ¡ZAS!¡En toda la boca!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;no such file to load -- zlib
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y por fín se pone interesante la cosa, veo un post específico para la configuración: &lt;a title=&quot;Ruby on Rails 3 and Ubuntu&quot; href=&quot;http://toranbillups.com/blog/archive/2010/09/01/How-to-install-Rails-3.0-and-Ruby-1.9.2-on-Ubuntu&quot; target=&quot;_blank&quot;&gt;How to install Rails 3.0 and Ruby 1.9.2 on Ubuntu&lt;/a&gt;, aunque me salto los dos primeros pasos, ya tengo instalado RVM y Ruby 1.8.7... sigo intentando pero nada de nada, sigue diciendo que no hay zlib... vaya. En &lt;a title=&quot;Stackoverflow: Ruby and Zlib&quot; href=&quot;http://stackoverflow.com/questions/2441248/rvm-ruby-1-9-1-troubles&quot; target=&quot;_blank&quot;&gt;Stackoverflow&lt;/a&gt; leo esto:&lt;br/&gt;&lt;blockquote&gt;rvm package install zlib&lt;br/&gt;rvm remove 1.9.1&lt;br/&gt;rvm install 1.9.1 -C --with-zlib-dir=$rvm_path/usr&lt;/blockquote&gt;&lt;br/&gt;Y en la &lt;a title=&quot;RVM y zlib&quot; href=&quot;http://rvm.beginrescueend.com/packages/zlib/&quot; target=&quot;_blank&quot;&gt;referencia de RVM&lt;/a&gt; esto:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;$ rvm package install zlib
$ rvm remove 1.9.2
$ rvm install 1.9.2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Esto parece más razonable... buf, otra vez a compilar... vamos a por un café que siempre viene bien.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Entorno de Ruby on Rails - Parte 2</title>
      <link>http://www.aguasnegras.es/blog/2010/10/13-Entorno de Ruby on Rails - Parte 2.html</link>
      <pubDate>sáb, 13 nov 2010 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2010/10/13-Entorno de Ruby on Rails - Parte 2.html</guid>
      	<description>
	&lt;p&gt;Bazinga! Eso era, por fín:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;case@aesir:~/.rvm/usr/lib$ gem update --system
Updating RubyGems
Nothing to update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Se vuelve a ejecutar el rvm --create y el --default y seguimos adelante, ahora a instalar rails con gem.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;gem install rails --version 3.0.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Muy bien, creo el directorio de proyecto y&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;rails new fist_app
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ya está creada, repaso los directorios y algún fichero de configuración según el tutorial e instalo los gems con bundle tal y como se especifica.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint linenums&quot;&gt;rails server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y ahí esta, funcionando sin problemas. Pasamos a recapitular.&lt;br/&gt;&lt;ul&gt;&lt;br/&gt; &lt;li&gt;Efectivamente, las herramientas son útiles y potentes, parece que se está pensando en todo.&lt;/li&gt;&lt;br/&gt; &lt;li&gt;La estructura de directorios parece también clara y estándar.&lt;/li&gt;&lt;br/&gt; &lt;li&gt;El uso de git y el incluir una carpeta tests por defecto, parece que sigue metodologías modernas, o mejor dicho, te guía al uso de las mismas.&lt;/li&gt;&lt;br/&gt; &lt;li&gt;El que haya una y solo una herramienta para cada cosa, no tienes que aprender a hacer lo mismo de 4 formas distintas.&lt;/li&gt;&lt;br/&gt;&lt;/ul&gt;&lt;br/&gt;Y poco más, de momento ya esta bien, mañana más y mejor.&lt;/p&gt;&lt;p&gt;Vamos a descogelar sushi pa la cena.&lt;/p&gt;
	</description>
    </item>

  </channel>
</rss>
