<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AguasNegras</title>
    <link>http://www.aguasnegras.es</link>
    <atom:link href="http://www.aguasnegras.es/feed.xml" rel="self" type="application/rss+xml" />
    <description>AguasNegras, tecnología, programación y Java</description>
    <language>es-es</language>
    <pubDate>lun, 6 jun 2016 13:22:55 +0200</pubDate>
    <lastBuildDate>lun, 6 jun 2016 13:22:55 +0200</lastBuildDate>

    <item>
      <title>Spring Boot Developer Tools e Intellij IDEA</title>
      <link>http://www.aguasnegras.es/blog/2016/05/30-springdevtoolsintellij.html</link>
      <pubDate>lun, 30 may 2016 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2016/05/30-springdevtoolsintellij.html</guid>
      	<description>
	&lt;p&gt;Una de las mejores incorporaciones que tuvo Spring Boot en la versión 1.3 fueron las &lt;a href=&quot;https://spring.io/blog/2015/06/17/devtools-in-spring-boot-1-3&quot;&gt;Developer Tools&lt;/a&gt;.&lt;br/&gt;De entre toda la funcionalidad, lo que me parece mas útil es sin lugar a dudas el automatic restart, que relanza la aplicación en cuanto detecta cambios en un&lt;br/&gt;fichero que esta en el classpath y el LiveReload, que en conjunción con un plugin de Chrome detecta cuando ha habido cambios en la aplicación (como un reinicio)&lt;br/&gt;y refresca automáticamente la página.&lt;/p&gt;&lt;p&gt;Juntando estas dos cosas, y dejando de lado el consumo de recursos, codificar en Java se convierte prácticamente en lo mismo que trabajar con un lenguaje de scripting&lt;br/&gt;como PHP.&lt;/p&gt;&lt;p&gt;Sin embargo, el soporte de los developers tools no es automático del todo en Intellij IDEA, el IDE que más suelo utilizar en casa, para ello hay que &lt;a href=&quot;https://patrickgrimard.io/2016/01/18/spring-boot-devtools-first-look/&quot;&gt;habilitar&lt;br/&gt;dos opciones&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;En Settings (ctrl-alt-s) &amp;gt; Build, Execution, Deployment &amp;gt; Compiler hay que marcar &quot;Make project automatically&quot;&lt;/li&gt;
  &lt;li&gt;En el registro que se puede acceder mediante ctrl-shift-a y buscando &quot;Registry&quot; hay que habilitar la clave compiler.automake.allow.when.app.running para que el&lt;br/&gt;automake funcione también mientras la aplicación esta arrancada.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Con ésto, y si tenemos un equipo suficientemente potente (aunque mi portátil tiene ya 5 años lo mueve bastante bien), cualquier cambio en nuestras clases se cargará&lt;br/&gt;automáticamente al reiniciar la aplicación. Eso sí, dado que Intellij IDEA guarda automáticamente los archivos cuando detecta cambios, esto puede dar lugar a algunos&lt;br/&gt;errores o reinicios en falso (por ejemplo, cuando estamos escribiendo un método y nos vamos a StackOverflow a resolver alguna duda). Para eso se pueden ajustar las&lt;br/&gt;opciones de autosave tal y como se explica en la misma &lt;a href=&quot;https://www.jetbrains.com/help/idea/2016.1/saving-and-reverting-changes.html&quot;&gt;documentación del IDE&lt;/a&gt;.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Wordpress to JBake - Parseo</title>
      <link>http://www.aguasnegras.es/blog/2016/03/20-wp2jbake.html</link>
      <pubDate>dom, 20 mar 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/03/20-wp2jbake.html</guid>
      	<description>
	&lt;p&gt;Pues ahora que ya tengo el constructor y construyo un objeto siempre que, al menos es coherente, toca parsear el xml para extraer los datos.&lt;br/&gt;En Java, esencialmente hay tres formas de parsear xml, todas dentro de lo que se denomina Java XML Processing API, &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/index.html&quot;&gt;JAXP&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/sax/index.html&quot;&gt;SAX&lt;/a&gt;: La API originaria, orientada a eventos. Muy rápida, muy eficiente y muy farragosa. Técnicamente es una API de streaming mediante push, es decir, nosotros arrancamos el procesamiento del documento y la API empieza a funcionar mandándonos eventos conforme va encontrando elementos.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/dom/index.html&quot;&gt;DOM&lt;/a&gt;: La API orientada a objetos, representa el XML como un árbol en memoria. Muy fácil de acceder, muy tragón de recursos. Técnicamente, se representa el árbol del DOM en memoria y listo, se puede acceder libremente, por ejemplo usando XPath.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jaxp/stax/index.html&quot;&gt;StAX&lt;/a&gt;: A partir del JDK 1.5 se encuentra disponible esta API que es un modelo mixto, se basa en un modelo de streaming (parecido a SAX) pero más sencillo de utilizar y además permite escribir. Técnicamente se define como una API de streming mediante pull, es decir, que somos nosotros los que vamos indicanto los elementos que queremos acceder. Eso sí, al ser de streaming solo permite avanzar en el documento, es decir, no podemos ignorar el elemento 1, tratar el 2 y en función de este retroceder a tratar el 1.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;En mi caso en particular, y dado que el modelo de &quot;ir hacia delante&quot; se adapta perfectamente al caso de uso (ya que simplemente estoy emparejando), pero tampoco necesito tantísima eficiencia ni tengo ganas de fastidiarme la vida, voy a utilizar StAX.&lt;/p&gt;&lt;p&gt;Pero lo primero, ahora que tengo que trabajar &quot;en serio&quot; es utilizar datos de verdad para las pruebas. Para eso hay dos opciones:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Guardo un XML de pruebas en forma de un String en un archivo .java y lo leo de ahí.&lt;/li&gt;
  &lt;li&gt;Guardo un archivo XML como tal.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Pues como que la primera opción es una tontería, he optado por la segunda. He sacado la exportación de datos que proporciona Wordpress y he dejado unos cuantos posts que sean más o menos representativos y listo. Lo guardo en &lt;em&gt;src/resources/wp-source.xml&lt;/em&gt;. Antes de seguir, ya no tiene sentido que los tests sigan usando el &lt;em&gt;pom.xml&lt;/em&gt; para las pruebas, así que lo cambio y lo lanzo. Todo en verde, como cabía esperar.&lt;/p&gt;&lt;p&gt;Ahora bien, ya tengo mi objeto de la clase Wp2JBake creado con el origen y el destino debidamente especificado, ¿como arranco el procesamiento? Hay que tener en cuenta que realmente el método de proceso no tiene por qué devolver nada, ya que el resultado efectivo de la salida es una estructura de archivos con el resultado de la conversión.&lt;br/&gt;Sin embargo, creo que es &quot;gratis&quot; devolver los elementos que se han generado y así se posibilita poder comprobar el resultado de la generación.&lt;/p&gt;&lt;p&gt;Así que primero el test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void processEmptyXML() {
    sut = new Wp2JBake(&amp;quot;src/test/resources/empty.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
    assertThat(markdowns, is(empty()));
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.delete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Obviamente, esta en rojo, allá va la implementación:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
    return new HashSet&amp;lt;File&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y aquí, ya voy devolviendo un Set (porque todos los elementos serán distintos, cada archivo representa un post y cada post es único) y uso uno no ordenado, porque en realidad me dá igual el orden de iteración, ya que &lt;a href=&quot;../02/04-wp2jbake.html&quot;&gt;como decidí&lt;/a&gt; los archivos vendrán ordenados por su ruta, es decir, si existen, por definición estan ordenados.&lt;/p&gt;&lt;p&gt;Vale, y ahora, test de verdad:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void processXML() {
    sut = new Wp2JBake(&amp;quot;src/test/resources/wp-source.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
    assertThat(markdowns, is(not(empty())));
    for (File markdown: markdowns) {
        assertThat(markdown.exists(), is(true));
    }
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.delete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora tengo que modificar el método &lt;em&gt;generateJBakeMarkdown&lt;/em&gt; para que genere los archivos Markdown. En un principio hay dos formas de hacer ésto:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Parseo el XML, genero una estructura de datos en memoria (una representación de los posts, vaya) y después la recorro y la paso a los archivos markdown. Desventaja, que para eso para qué demonios uso StAX y el streaming, si voy a comer memoria uso DOM y listo.&lt;/li&gt;
  &lt;li&gt;Parseo el XML y cada vez que se detecte un item (un post) lo voy escribiendo dinámicamente. Creo que esta opción es más complicada, pero más ligera.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Vamos a por 2, para ello leeré el XML y lo volcaré... pero un momento, una cosa es saber leer el XML y otra escribir el Markdown, es decir, que mi clase lectora (_Wp2JBake_) a su vez debe comunicarse (usar) otra para escribir (_MdWriter_).&lt;br/&gt;Pensando un poco más sobre esta clase &lt;em&gt;MdWriter&lt;/em&gt;... debería recibir como parámetro en su constructor el destino de las escrituras y eso me lleva a pensar, que realmente es a ella a la que le corresponde comprobar si es un destino legal, es decir, que el constructor de &lt;em&gt;Wp2JBake&lt;/em&gt; ahora quedaría así (también he aprovechado y &lt;em&gt;origin&lt;/em&gt; lo he guardado en un atributo de la clase):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    } else {
        this.origin = origin;
    }
    this.mdWriter = new MdWriter(destination);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Mientras que &lt;em&gt;MdWriter&lt;/em&gt; sería así:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class MdWriter {

    private File destinationFolder;

    public MdWriter(String destination) {
        if (StringUtils.isEmpty(destination) || !isWritable(destination)) {
            throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
        } else {
            destinationFolder = new File(destination);
        }
    }

    private boolean isWritable(String destination) {
        File destinationFolder = new File(destination);
        if (destinationFolder.exists()) {
            return destinationFolder.canWrite();
        } else {
            return isWritableDestinationParent(destinationFolder);
        }
    }

    private boolean isWritableDestinationParent(File destinationFolder) {
        File destinationParent = getDestinationParent(destinationFolder);
        return destinationParent.canWrite();
    }

    private File getDestinationParent(File destinationFolder) {
        String parentPath = destinationFolder.getParent();
        if (parentPath == null) {
            parentPath = &amp;quot;&amp;quot;;
        }
        return new File(parentPath);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por cierto que la teoría TDDista dice que esto no debería hacerse, que primero hay que pasar el test y después ponerse a refactorizar y tal... Hombre, yo eso no lo comparto tanto, creo que esta bien ir pensando un poco las cosas. Además, como ya tengo hechos los tests, los puedo volver a ejecutar para ver que no me he cargado nada.&lt;br/&gt;Que hablando de las pruebas, ahora tengo que crear las pruebas propias de esta nueva clase y llevarme todas las encargadas de testear la corrección del directorio destino a esa clase. Al separarlo además ya no tengo que diferenciar entre los tipos de excepción (era muy cantoso que estaba pasando del Single Responsability) y el código queda mucho más limpio:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class Wp2JBakeTests {

    private Wp2JBake sut;

    @Test(expected = IllegalArgumentException.class)
    public void buildWithoutParameters() {
        sut = new Wp2JBake(null, null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithoutOrigin() {
        sut = new Wp2JBake(null, &amp;quot;foo&amp;quot;);

    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithEmptyOrigin() {
        sut = new Wp2JBake(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithInvalidOrigin() {
        sut = new Wp2JBake(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;);
    }

    @Test
    public void buildWithValidParameters() {
        sut = new Wp2JBake(&amp;quot;src/test/resources/wp-source.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    }

    @Test
    public void processEmptyXML() {
        sut = new Wp2JBake(&amp;quot;src/test/resources/empty.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
        Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
        assertThat(markdowns, is(empty()));
    }

    @Test
    public void processXML() {
        sut = new Wp2JBake(&amp;quot;src/test/resources/wp-source.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
        Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
        assertThat(markdowns, is(not(empty())));
        for (File markdown: markdowns) {
            assertThat(markdown.exists(), is(true));
        }
        File destination = new File(&amp;quot;destination&amp;quot;);
        destination.delete();
    }
}

public class MdWriterTest {

    private MdWriter sut;

    @Test(expected = IllegalArgumentException.class)
    public void writerWithoutDestination() {
        sut = new MdWriter(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithEmptyDestination() {
        sut = new MdWriter(&amp;quot;&amp;quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestination() {
        File destination = new File(&amp;quot;destination&amp;quot;);
        destination.mkdir();
        destination.deleteOnExit();
        destination.setReadOnly();
        sut = new MdWriter(destination.getAbsolutePath());
    }

    @Test(expected = IllegalArgumentException.class)
    public void writerWithNonWritableDestinationParent() {
        File destinationParent = new File(&amp;quot;destinationParent&amp;quot;);
        destinationParent.mkdir();
        destinationParent.deleteOnExit();
        destinationParent.setReadOnly();
        sut = new MdWriter(destinationParent.getAbsolutePath() + File.separator + &amp;quot;destination&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bueno, pues ahora tengo que leer el XML e ir cargando los Strings que el escritor se encargará de volcar a disco... muy bien. Lo primer es crear la factoría de eventos. Por cierto, menuda bazofia el tutorial oficial de Oracle, menos mal que &lt;a href=&quot;http://www.vogella.com/tutorials/JavaXML/article.html&quot;&gt;Lars Vogel&lt;/a&gt; tiene un grandísimo tutorial (danke schön Lars!):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
        XMLEventReader eventReader = getEventReader();
        return new HashSet&amp;lt;File&amp;gt;();
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&amp;quot;Could not find origin file: &amp;quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Could not read origin file: &amp;quot; + e.getMessage());
        }
        return eventReader;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;He optado por lanzar un IllegalStateException si ocurre alguna de las excepciones, ya que eso no debería ocurrir y a lo que lleva es exactamente a eso, un estado ilegal del programa :)&lt;br/&gt;Hmmm... por otra parte, tengo la prueba con el XML vacío, pero ahora que lo pienso ¡¡¡no tengo ninguna con un XML inválido!!! Me creo un XML &lt;em&gt;invalid.xml&lt;/em&gt; que contiene solo la cabecera con un número de versión que no existe:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;&amp;lt;?xml version=&amp;quot;-1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y su test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test(expected = IllegalStateException.class)
public void processInvalidXML() {
    sut = new Wp2JBake(&amp;quot;src/test/resources/invalid.xml&amp;quot;, &amp;quot;src/test/destination&amp;quot;);
    Set&amp;lt;File&amp;gt; markdowns = sut.generateJBakeMarkdown();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Me esta empezando a parecer que la lectura también debería ir en otra clase y &lt;em&gt;Wp2JBake&lt;/em&gt; tan solo orquestrar la lectura con la escritura... pero bueno, ya iremos viendo de momento sigo, así. Toca tratar los eventos. El tutorial hace un típico bucle while con el eventReader que implementa &lt;em&gt;Iterator&lt;/em&gt;, pero claro, el tutorial es antiguo, al fin y al cabo y pensándolo bien... yo lo que quiero hacer es un filter y un collect, es decir, que puedo usar la API de Streams de Java 8. La única historia es convertir el &lt;em&gt;XMLEventReader&lt;/em&gt; a un &lt;em&gt;Stream&lt;XMLEvent&gt;&lt;/em&gt;, pero eso es relativamente fácil:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
    XMLEventReader eventReader = getEventReader();
    Iterable&amp;lt;XMLEvent&amp;gt; eventsIterable = () -&amp;gt; eventReader;
    Stream&amp;lt;XMLEvent&amp;gt; xmlEvents = StreamSupport.stream(eventsIterable.spliterator(), false);
    return new HashSet&amp;lt;File&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bueno, pues después de echar hora y pico probando con filter, map, flatmap etc, hay un problema, y es que StAX entiende todo el documento secuencialmente, con lo cual no puedo hacer un filter y quedarme solo con los elemntos de tipo &lt;em&gt;item&lt;/em&gt; y después acceder a los elementos que contienen estos, porque un elemento esta suelto, así que nada, toca iteradores y bucles for de toda la vida. Para que sea más entendible (y orientado a objetos), me voy a crear una clase &lt;em&gt;Post&lt;/em&gt; para ir guardando los resultados y después volcarlos al archivo pertinente.&lt;br/&gt;Esta clase la monto con una API fluida para que la construcción me sea más sencilla y los correspondientes getters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class Post {
    private String title;

    private LocalDate publishingDate;

    private Set&amp;lt;String&amp;gt; tags = new TreeSet&amp;lt;&amp;gt;();

    private String content;

    public Post () {

    }

    public Post withTitle(String title) {
        this.title = title;
        return this;
    }

    public Post withPublishingDate(LocalDate publishingDate) {
        this.publishingDate = publishingDate;
        return this;
    }

    public Post withTag(String tag) {
        this.tags.add(tag);
        return this;
    }

    public Post withContent(String content) {
        this.content = content;
        return this;
    }

    public String getTitle() {
        return title;
    }

    public LocalDate getPublishingDate() {
        return publishingDate;
    }

    public Set&amp;lt;String&amp;gt; getTags() {
        return tags;
    }

    public String getContent() {
        return content;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;En fín, ya han pasado como tres horas y el test sigue sin funcionar... me deprimo...&lt;br/&gt;Sigo con el for, la estrategia es muy sencilla, si detecto un elemento &lt;em&gt;item&lt;/em&gt;, creo un nuevo &lt;em&gt;Post&lt;/em&gt; y conforme vaya detectando los elementos &lt;em&gt;title&lt;/em&gt;, &lt;em&gt;pubDate&lt;/em&gt;, &lt;em&gt;category&lt;/em&gt; y &lt;em&gt;content&lt;/em&gt; voy invocando a los métodos &lt;em&gt;with*&lt;/em&gt; del &lt;em&gt;Post&lt;/em&gt;. En el momento que detecte el cierre del &lt;em&gt;item&lt;/em&gt;, escribo a disco:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
    XMLEventReader eventReader = getEventReader();
    Iterable&amp;lt;XMLEvent&amp;gt; eventsIterable = () -&amp;gt; eventReader;
    Stream&amp;lt;XMLEvent&amp;gt; xmlEvents = StreamSupport.stream(eventsIterable.spliterator(), false);
    return new HashSet&amp;lt;File&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Desafortunadamente, el tema es más complejo de lo que parecía. Dado que StAX solo lee en un sentido (palante), de poco me sirve la API de streams de Java 8, ya que tengo que ir tomando decisiones en función del elemento que llegue, por ejemplo, un elemento &lt;em&gt;title&lt;/em&gt; se debe ignorar salvo que previamente se haya recibido un &lt;em&gt;item&lt;/em&gt;.&lt;br/&gt;No digo que no sea posible hacerlo con streams, solo que después de muchos relíos es más sencillo hacerlo con dos while:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;El primer while que itera sobre todos los elementos proporcionados por StAX.&lt;/li&gt;
  &lt;li&gt;El segundo while empieza cuando se detecta un &lt;em&gt;item&lt;/em&gt; y termina cuando se cierra el &lt;em&gt;item&lt;/em&gt;, leyendo por tanto un post completo.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Con esto en mente es bastante fácil:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
        HashSet&amp;lt;File&amp;gt; exportResult = new HashSet&amp;lt;&amp;gt;();
        XMLEventReader eventReader = getEventReader();
        try {
            exportPosts(exportResult, eventReader);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error reading XML &amp;quot; + origin + &amp;quot;: &amp;quot; + e.getMessage());
        }
        return exportResult;
    }

    private void exportPosts(HashSet&amp;lt;File&amp;gt; exportResult, XMLEventReader eventReader) throws XMLStreamException {
        Post post = null;
        while (eventReader.hasNext()) {
                XMLEvent event = eventReader.nextEvent();
                if (isPostStart(event)) {
                    post = exportPost(exportResult, eventReader, post);
                }
        }
    }

    private Post exportPost(HashSet&amp;lt;File&amp;gt; exportResult, XMLEventReader eventReader, Post post) throws XMLStreamException {
        if (post != null) {
            exportResult.add(mdWriter.write(post));
        }
        post = readPost(eventReader);
        return post;
    }

    private Post readPost(XMLEventReader eventReader) throws XMLStreamException {
        Post exportedPost = new Post();
        boolean postRead = false;
            while (!postRead &amp;amp;&amp;amp; eventReader.hasNext()) {
                XMLEvent event = eventReader.nextEvent();
                if (event.isStartElement()) {
                    exportedPost = loadPostFromEvent(event, eventReader, exportedPost);
                } else if (isPostEnd(event)) {
                    postRead = true;
                }
            }
        return exportedPost;
    }

    private boolean isPostEnd(XMLEvent event) {
        return event.isEndElement() &amp;amp;&amp;amp; &amp;quot;item&amp;quot;.equals(event.asEndElement().getName().getPrefix() + event.asEndElement().getName().getLocalPart());
    }

    private boolean isPostStart(XMLEvent event) {
        return event.isStartElement() &amp;amp;&amp;amp; &amp;quot;item&amp;quot;.equals(getEventFullName(event));
    }

    private Post loadPostFromEvent(XMLEvent event, XMLEventReader eventReader, Post post) {
        String name = getEventFullName(event);
        try {
            switch (name) {
                case &amp;quot;title&amp;quot;:
                    post = loadTitle(eventReader, post);
                    break;
                case &amp;quot;pubDate&amp;quot;:
                    post = loadPublishingDate(eventReader, post);
                    break;
                case &amp;quot;category&amp;quot;:
                    if (isTag(event)) {
                        post = loadCategory(eventReader, event, post);
                    }
                    break;
                case &amp;quot;contentencoded&amp;quot;:
                    post = loadContent(eventReader, post);
                    break;
                default:
                    break;
            }
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error parsing &amp;quot; + name + &amp;quot;: &amp;quot; + e.getMessage());
        }
        return post;
    }

    private Post loadContent(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withContent(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadCategory(XMLEventReader eventReader, XMLEvent event, Post post) throws XMLStreamException {
            return post.withTag(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadPublishingDate(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withPublishingDate(parsePubDate(eventReader));
    }

    private Post loadTitle(XMLEventReader eventReader, Post post) throws XMLStreamException {
            return post.withTitle(eventReader.nextEvent().asCharacters().getData());
    }

    private String getEventFullName(XMLEvent event) {
        return event.asStartElement().getName().getPrefix() + event.asStartElement().getName().getLocalPart();
    }

    private boolean isTag(XMLEvent event) {
        return &amp;quot;post_tag&amp;quot;.equals(event.asStartElement().getAttributeByName(new QName(&amp;quot;domain&amp;quot;)).getValue());
    }


    private Date parsePubDate(XMLEventReader eventReader) throws XMLStreamException {
        Date publishingDate = null;
        try {
            String pubDate = eventReader.nextEvent().asCharacters().getData();
            pubDate = extractDate(pubDate);
            SimpleDateFormat format = new SimpleDateFormat(&amp;quot;dd MMM yyyy&amp;quot;);
            publishingDate = format.parse(pubDate);
        } catch (ParseException e) {
            throw new IllegalStateException(&amp;quot;Could not parse pubDate: &amp;quot; + e.getMessage());
        }
        return publishingDate;
    }

    private String extractDate(String pubDate) {
        //Date is supplied as this: Wed, 30 Nov -0001 00:00:00 +0000, we need to extract just the date
        pubDate = pubDate.substring(pubDate.indexOf(&amp;quot;,&amp;quot;)+2);
        int hourIndex = pubDate.indexOf(&amp;quot;:&amp;quot;)-3;
        pubDate = pubDate.substring(0, hourIndex);
        return pubDate;
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&amp;quot;Could not find origin file: &amp;quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Could not read origin file: &amp;quot; + e.getMessage());
        }
        return eventReader;
    }

    private boolean existsOrigin(String origin) {
        File originFile = new File(origin);
        String path = originFile.getAbsolutePath();
        return originFile.exists();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Lo del parseo de la fecha ha sido un espectáculo... no he sido capaz de sacarlo con el DateFormatter para convertirlo a un LocalDate.&lt;br/&gt;Bueno, pues ahora que lo tengo... ¿no tendría más sentido que todo eso fuera a una clase propia? Digamos WpReader. Pues sí, porque ahora mismo mi clase principal se esta responsabilizando de saber como se leen los posts y qué hacer con los posts leidos, así que es mucho más claro hacerlo con una colaboradora.&lt;br/&gt;Pero claro, si me llevo la lógica aparte, ¿cómo aviso de que se puede escribir un nuevo post sin romper el while que itera sobre todos los elementos del XML?&lt;br/&gt;Bueno, pues finamente diría que voy a usar un patrón observador, para notificar de cuando hay un nuevo post. Técnicamente lo que voy a hacer es implementar un callback y así &lt;em&gt;Wp2JBake&lt;/em&gt; queda mucho más clara:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class Wp2JBake {

    private WpReader wpReader;

    private MdWriter mdWriter;

    private HashSet&amp;lt;File&amp;gt; exportResult;

    public Wp2JBake(String origin, String destination) {
        this.wpReader = new WpReader(origin);
        this.mdWriter = new MdWriter(destination);
    }

    public Set&amp;lt;File&amp;gt; generateJBakeMarkdown() {
        exportResult = new HashSet&amp;lt;&amp;gt;();
        wpReader.readPosts(this);
        return exportResult;
    }

    public void postRead(Post post) {
        exportResult.add(mdWriter.write(post));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y por otro lado tenemos &lt;em&gt;WpReader&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public class WpReader {

    public static final String ITEM = &amp;quot;item&amp;quot;;
    public static final String TITLE = &amp;quot;title&amp;quot;;
    public static final String PUB_DATE = &amp;quot;pubDate&amp;quot;;
    public static final String CATEGORY = &amp;quot;category&amp;quot;;
    public static final String CONTENT = &amp;quot;contentencoded&amp;quot;;
    public static final String POST_TAG = &amp;quot;post_tag&amp;quot;;
    public static final String DOMAIN = &amp;quot;domain&amp;quot;;
    private String origin;

    public WpReader(String origin) {
        if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
            throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
        } else {
            this.origin = origin;
        }
    }

    private boolean existsOrigin(String origin) {
        File originFile = new File(origin);
        return originFile.exists();
    }

    public void readPosts(Wp2JBake wp2JBake) {
        XMLEventReader eventReader = getEventReader();
        try {
            readXML(wp2JBake, eventReader);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error reading XML &amp;quot; + origin + &amp;quot;: &amp;quot; + e.getMessage());
        }
    }

    private void readXML(Wp2JBake wp2JBake, XMLEventReader eventReader) throws XMLStreamException {
        while (eventReader.hasNext()) {
            readElement(wp2JBake, eventReader);
        }
    }

    private void readElement(Wp2JBake wp2JBake, XMLEventReader eventReader) throws XMLStreamException {
        XMLEvent event = eventReader.nextEvent();
        if (isPostStart(event)) {
            Post post = readPost(eventReader);
            wp2JBake.postRead(post);
        }
    }

    private Post readPost(XMLEventReader eventReader) throws XMLStreamException {
        Post exportedPost = new Post();
        boolean postRead = false;
        while (!postRead &amp;amp;&amp;amp; eventReader.hasNext()) {
            XMLEvent event = eventReader.nextEvent();
            if (event.isStartElement()) {
                exportedPost = loadAttribute(event, eventReader, exportedPost);
            } else if (isPostEnd(event)) {
                postRead = true;
            }
        }
        return exportedPost;
    }

    private boolean isPostEnd(XMLEvent event) {
        return event.isEndElement() &amp;amp;&amp;amp; ITEM.equals(event.asEndElement().getName().getPrefix() + event.asEndElement().getName().getLocalPart());
    }

    private Post loadAttribute(XMLEvent event, XMLEventReader eventReader, Post post) {
        String name = getEventFullName(event);
        try {
            post = loadAttribute(event, eventReader, post, name);
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Error parsing &amp;quot; + name + &amp;quot;: &amp;quot; + e.getMessage());
        }
        return post;
    }

    private Post loadAttribute(XMLEvent event, XMLEventReader eventReader, Post post, String name) throws XMLStreamException {
        switch (name) {
            case TITLE:
                post = loadTitle(eventReader, post);
                break;
            case PUB_DATE:
                post = loadPublishingDate(eventReader, post);
                break;
            case CATEGORY:
                if (isTag(event)) {
                    post = loadCategory(eventReader, post);
                }
                break;
            case CONTENT:
                post = loadContent(eventReader, post);
                break;
            default:
                break;
        }
        return post;
    }

    private Post loadContent(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withContent(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadCategory(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withTag(eventReader.nextEvent().asCharacters().getData());
    }

    private Post loadPublishingDate(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withPublishingDate(parsePubDate(eventReader));
    }

    private Post loadTitle(XMLEventReader eventReader, Post post) throws XMLStreamException {
        return post.withTitle(eventReader.nextEvent().asCharacters().getData());
    }

    private boolean isTag(XMLEvent event) {
        return POST_TAG.equals(event.asStartElement().getAttributeByName(new QName(DOMAIN)).getValue());
    }


    private Date parsePubDate(XMLEventReader eventReader) throws XMLStreamException {
        Date publishingDate = null;
        try {
            String pubDate = eventReader.nextEvent().asCharacters().getData();
            pubDate = extractDate(pubDate);
            SimpleDateFormat format = new SimpleDateFormat(&amp;quot;dd MMM yyyy&amp;quot;);
            publishingDate = format.parse(pubDate);
        } catch (ParseException e) {
            throw new IllegalStateException(&amp;quot;Could not parse pubDate: &amp;quot; + e.getMessage());
        }
        return publishingDate;
    }

    private String extractDate(String pubDate) {
        //Date is supplied as this: Wed, 30 Nov -0001 00:00:00 +0000 (RFC822 presumably), we need to extract just the date
        pubDate = pubDate.substring(pubDate.indexOf(&amp;quot;,&amp;quot;)+2);
        int hourIndex = pubDate.indexOf(&amp;quot;:&amp;quot;)-3;
        pubDate = pubDate.substring(0, hourIndex);
        return pubDate;
    }

    private boolean isPostStart(XMLEvent event) {
        return event.isStartElement() &amp;amp;&amp;amp; ITEM.equals(getEventFullName(event));
    }

    private String getEventFullName(XMLEvent event) {
        return event.asStartElement().getName().getPrefix() + event.asStartElement().getName().getLocalPart();
    }

    private XMLEventReader getEventReader() {
        XMLInputFactory inputFactory = XMLInputFactory.newInstance();
        InputStream in = null;
        XMLEventReader eventReader = null;
        try {
            in = new FileInputStream(origin);
            eventReader = inputFactory.createXMLEventReader(in);
        } catch (FileNotFoundException e) {
            throw new IllegalStateException(&amp;quot;Could not find origin file: &amp;quot; + e.getMessage());
        } catch (XMLStreamException e) {
            throw new IllegalStateException(&amp;quot;Could not read origin file: &amp;quot; + e.getMessage());
        }
        return eventReader;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pues para terminar con esta sección que se ha alargado más de lo que esperaba, me queda modificar los tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@RunWith(MockitoJUnitRunner.class)
public class WpReaderTest {

    private WpReader sut;

    @Mock
    private Wp2JBake observer;

    @Test(expected = IllegalArgumentException.class)
    public void readerWithoutOrigin() {
        sut = new WpReader(null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void readerWithEmptyOrigin() {
        sut = new WpReader(&amp;quot;&amp;quot;);
    }

    @Test(expected = IllegalArgumentException.class)
    public void buildWithInvalidOrigin() {
        sut = new WpReader(&amp;quot;foo&amp;quot;);
    }

    @Test(expected = IllegalStateException.class)
    public void readEmptyXML() {
        sut = new WpReader(&amp;quot;src/test/resources/empty.xml&amp;quot;);
        sut.readPosts(observer);
    }

    @Test(expected = IllegalStateException.class)
    public void readInvalidXML() {
        sut = new WpReader(&amp;quot;src/test/resources/invalid.xml&amp;quot;);
        sut.readPosts(observer);
    }

    @Test
    public void readValidXML() {
        sut = new WpReader(&amp;quot;src/test/resources/wp-source.xml&amp;quot;);
        ArgumentCaptor&amp;lt;Post&amp;gt; postCapturer = ArgumentCaptor.forClass(Post.class);
        sut.readPosts(observer);
        verify(observer, times(7)).postRead(postCapturer.capture());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Con esto ya ha quedado perfecto, si no tanto el software, si los tests. Cada clase tiene una responsabilidad bien definida y así se refleja en los tests. Eso sí, en esta última clase he tenido que meter Mockito para simular el &lt;em&gt;Wp2JBake&lt;/em&gt; que me hace falta para el callback. Lo bueno de esto es que con Mockito puedo verificar las llamadas a los métodos y por primera vez tengo todos los tests en verde.&lt;br/&gt;Eso sí, los tests de &lt;em&gt;Wp2JBake&lt;/em&gt; se han quedado en realidad como pruebas de integración, así que no me preocupa que el test original siga en rojo porque realmente hasta que no este implementada la escritura no debería pasar a verde :).&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Wordpress to JBake - Inicio</title>
      <link>http://www.aguasnegras.es/blog/2016/02/04-wp2jbake.html</link>
      <pubDate>jue, 4 feb 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/02/04-wp2jbake.html</guid>
      	<description>
	&lt;p&gt;En la migraci&amp;oacute;n del blog a GitHub Pages uno de los objetivos era no perder contenido, por lo que una vez puesta en pie toda la infraestructura, toca migrar los posts (mucho me temo que los comentarios si se van a perder...). Soluci&amp;oacute;n: Hacer un peque&amp;ntilde;o programa en Java (casi que dir&amp;iacute;a script) que realice autom&amp;aacute;ticamente esta conversi&amp;oacute;n, adem&amp;aacute;s voy a seguir TDD para &quot;mantenerme en forma&quot;.&lt;br/&gt;En un principio lo voy a plantear como una mera conversi&amp;oacute;n de formatos, como formato inicial tengo el que devuelve Wordpress para la exportaci&amp;oacute;n: &lt;a href=&quot;http://devtidbits.com/2011/03/16/the-wordpress-extended-rss-wxr-exportimport-xml-document-format-decoded-and-explained/&quot;&gt;Wordpress Extended RSS&lt;/a&gt; y como formato final quiero un archivo en el formato espec&amp;iacute;fico de JBake, que no deja de ser &lt;a href=&quot;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&quot;&gt;Markdown&lt;/a&gt; con unas cabeceras (metadata) particulares:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;title: El t&amp;iacute;tulo del post&lt;/li&gt;
  &lt;li&gt;date: La fecha del post&lt;/li&gt;
  &lt;li&gt;type: Ser&amp;aacute; siempre post&lt;/li&gt;
  &lt;li&gt;tags: Las etiquetas del post&lt;/li&gt;
  &lt;li&gt;status: Ser&amp;aacute; siempre published&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;El WXR es un solo archivo con una serie de elementos item que corresponde cada uno a un post, un elemento item tiene los siguientes campos interesantes:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;title: casa con la cabecera title que quiero&lt;/li&gt;
  &lt;li&gt;pubdate: casa con la cabecera date&lt;/li&gt;
  &lt;li&gt;category: Las categor&amp;iacute;as se dividen en dominios que puede ser category (bien Wordpress, bien) o post_tag, en concreto me interesan solo aquellas de tipo post_tag y su contenido, es decir tendr&amp;eacute; que concatener el contenido de todas las categor&amp;iacute;as de tipo post_tag.&lt;/li&gt;
  &lt;li&gt;content: Este es el contenido el post en s&amp;iacute;, como se puede ver viene en HTML tal cual dentro de un CDATA, esto me permite aprovechar que con Markdown puedo utilizar el HTML inline as&amp;iacute; que en un principio lo voy a volcar tal cual, aunque preveo ciertos problemas con las etiquetas de c&amp;oacute;digo...&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Por &amp;uacute;ltimo, por cada item quiero generar un archivo con el nombre dd-title.md (donde dd es el d&amp;iacute;a de la fecha) dentro de una carpeta mm (mes) dentro de una carpeta aaaa (a&amp;ntilde;o...).&lt;/p&gt;&lt;p&gt;Pues con esto, empezamos!! Primero: crear el projecto en Intellij y con Maven, creo el repositorio en &lt;a href=&quot;https://github.com/agustinventura/wp2jbake&quot;&gt;GitHub&lt;/a&gt; y lo a&amp;ntilde;ado.&lt;br/&gt;A continuaci&amp;oacute;n, actualizo el .gitignore, hago el commit inicial y cambio a la rama development.&lt;/p&gt;&lt;p&gt;El comienzo es un no brainer, necesito un main que arranque la aplicaci&amp;oacute;n como tal y que recibir&amp;aacute; como par&amp;aacute;metros:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;El nombre del archivo WXR&lt;/li&gt;
  &lt;li&gt;El directorio de salida&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Eso quiere decir que la clase de entrada a la aplicaci&amp;oacute;n (Wp2JBake) tendr&amp;aacute; un constructor con dos par&amp;aacute;metros, as&amp;iacute; que siguiendo TDD, empiezo con los tests:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Construir con los par&amp;aacute;metros a null.&lt;/li&gt;
  &lt;li&gt;Construir con el archivo origen a null.&lt;/li&gt;
  &lt;li&gt;Construir con el directorio destino a null.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;En todos estos casos lanzar&amp;eacute; una InvalidArgumentException, as&amp;iacute; que inicialmente tendr&amp;iacute;a como pruebas algo as&amp;iacute;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;private Wp2JBake sut;

@Test(expected = IllegalArgumentException.class)
public void buildWithoutParameters() {
    sut = new Wp2JBake(null, null);
}

@Test(expected = IllegalArgumentException.class)
public void buildWithoutOrigin() {
    sut = new Wp2JBake(null, &amp;quot;&amp;quot;);
}

@Test(expected = IllegalArgumentException.class)
public void buildWithoutDestination() {
    sut = new Wp2JBake(&amp;quot;&amp;quot;, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y como implementaci&amp;oacute;n lo siguiente:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (origin == null) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (destination == null) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pero... un segundo, &amp;iquest;me d&amp;aacute; igual la IllegalArgumentException que se lanza? No, en cada caso quiero verificar que se esta lanzando la que se debe, refactorizo las pruebas, ahora voy a utilizar un @Rule de JUnit para comprobar que se lanza la excepci&amp;oacute;n y el mensaje de error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Rule
public ExpectedException thrown = ExpectedException.none();

private Wp2JBake sut;

@Test
public void buildWithoutParameters() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(null, null);
}

@Test
public void buildWithoutOrigin() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(null, &amp;quot;foo&amp;quot;);

}

@Test
public void buildWithoutDestination() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;foo&amp;quot;, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Vale, ya he controlado que no sea null, ahora toca comprobar que tampoco sea cadena vac&amp;iacute;a:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt; @Test
public void buildWithEmptyOrigin() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(&amp;quot;&amp;quot;, &amp;quot;&amp;quot;);
}

@Test
public void buildWithEmptyDestination() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ahora toca cambiar la implementaci&amp;oacute;n, me voy a apoyar en las commons-lang:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (StringUtils.isEmpty(destination)) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Siguiente restricci&amp;oacute;n, el origen adem&amp;aacute;s debe existir:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void buildWithInvalidOrigin() {
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Origin&amp;quot;);
    sut = new Wp2JBake(&amp;quot;foo&amp;quot;, &amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y la implementaci&amp;oacute;n:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (StringUtils.isEmpty(destination)) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}

private boolean existsOrigin(String origin) {
    File originFile = new File(origin);
    return originFile.exists();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Esta implementaci&amp;oacute;n hace saltar las pruebas de origen inv&amp;aacute;lido, claro como para &quot;callar&quot; los tests estoy pasando como primer par&amp;aacute;metro una cadena cualquiera, ahora falla porque no existe el par&amp;aacute;metro foo.&lt;br/&gt;Aqu&amp;iacute; hay dos opciones:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Pasar un archivo que si exista.&lt;/li&gt;
  &lt;li&gt;Cambiar la implementaci&amp;oacute;n para que primero compruebe que la cadena es v&amp;aacute;lida en los dos casos y despu&amp;eacute;s que compruebe si el archivo es v&amp;aacute;lido.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;El problema de 2 es que tendr&amp;iacute;a que lanzar la misma excepci&amp;oacute;n dos veces mientras que el de 1 es que se parecer&amp;iacute;a m&amp;aacute;s a un test de integraci&amp;oacute;n que a una prueba unitaria en s&amp;iacute;. Para mi gusto esta es una de las zonas grises en TDD, porque, &amp;iquest;ahora qu&amp;eacute; hago?&amp;iquest;Creo un mock del SUT? No lo veo claro,&lt;br/&gt;as&amp;iacute; que tratar&amp;eacute; de tirar por el camino del medio y pasar una ruta de archivo que sepa que siempre existe, por ejemplo, el pom.xml.&lt;/p&gt;&lt;p&gt;Ahora podr&amp;iacute;a seguir comprobando que el destino no sea inv&amp;aacute;lido, pero... &amp;iquest;puede serlo? Al ser un directorio, si no existe, deber&amp;iacute;a crearlo y si existe, no hacer nada. En todo caso la comprobaci&amp;oacute;n deber&amp;iacute;a ser si se puede crear el directorio y si se puede escribir en &amp;eacute;l.&lt;/p&gt;&lt;p&gt;De aqu&amp;iacute; saco estas dos pruebas:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void buildWithNonWritableDestination() {
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.mkdir();
    destination.deleteOnExit();
    destination.setReadOnly();
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;pom.xml&amp;quot;, destination.getAbsolutePath());
}

@Test
public void buildWithNonWritableDestinationParent() {
    File destinationParent = new File(&amp;quot;destinationParent&amp;quot;);
    destinationParent.mkdir();
    destinationParent.deleteOnExit();
    destinationParent.setReadOnly();
    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage(&amp;quot;Destination&amp;quot;);
    sut = new Wp2JBake(&amp;quot;pom.xml&amp;quot;, destinationParent.getAbsolutePath() + File.separator + &amp;quot;destination&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Y la implementaci&amp;oacute;n sigue creciento:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;public Wp2JBake(String origin, String destination) {
    if (StringUtils.isEmpty(origin) || !existsOrigin(origin)) {
        throw new IllegalArgumentException(&amp;quot;Origin is not a valid file&amp;quot;);
    }
    if (StringUtils.isEmpty(destination) || !isWritable(destination)) {
        throw new IllegalArgumentException(&amp;quot;Destination is not a valid folder&amp;quot;);
    }
}

private boolean isWritable(String destination) {
    File destinationFolder = new File(destination);
    if (destinationFolder.exists()) {
        return destinationFolder.canWrite();
    } else {
        return destinationFolder.getParentFile().canWrite();
    }
}

private boolean existsOrigin(String origin) {
    File originFile = new File(origin);
    String path = originFile.getAbsolutePath();
    return originFile.exists();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Por &amp;uacute;ltimo me quedar&amp;iacute;a probar el caso en el que ambos par&amp;aacute;metros son v&amp;aacute;lidos:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint&quot;&gt;@Test
public void buildWithValidParameters() {
    sut = new Wp2JBake(&amp;quot;pom.xml&amp;quot;, &amp;quot;destination&amp;quot;);
    File destination = new File(&amp;quot;destination&amp;quot;);
    destination.delete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Con esto puedo empezar a refactorizar y a remplatearme las cosas. La verdad que Wp2JBake empieza a tener un tama&amp;ntilde;o considerable teniendo en cuenta que tan s&amp;oacute;lo tiene como API un constructor. La verdad que las comprobaciones que estoy haciendo sobre los par&amp;aacute;metros no me convencen, me dan la impresi&amp;oacute;n de que estoy violando el Single Responsability, por otra parte ser&amp;iacute;a un poco artificial crear una clase de validadores &amp;uacute;nicamente.&lt;/p&gt;
	</description>
    </item>
    <item>
      <title>Migrando el blog</title>
      <link>http://www.aguasnegras.es/blog/2016/01/03-migracion.html</link>
      <pubDate>dom, 3 ene 2016 00:00:00 +0100</pubDate>
      <guid isPermaLink="false">blog/2016/01/03-migracion.html</guid>
      	<description>
	&lt;p&gt;Desde hace ya bastantes años llevo pagando religiosamente todos los años un dominio (aguasnegras.es) y un alojamiento para tener el blog.&lt;br/&gt;El blog ha tenido mejores y peores momentos, pero en general me gusta tener un sitio donde poder escribir en un momento dado, y por supuesto compartir con la comunidad (sobre todo en español, es por lo que escribo en este idioma).&lt;/p&gt;&lt;p&gt;El asunto es que si nos paramos a pensarlo, el blog tiene bastantes pocos comentarios y sobre todo entradas mías, es decir, es fundamentalmente un medio de solo lectura. Hace ya un tiempo que pienso que tener para ésto un Wordpress con su PHP y su MySQL es bastante asesino y hasta antieconómico (en sentido general, porque el hosting me cuesta cuatro duros al año, tampoco vamos a ser ruinas). Otra cosa que me molesta bastante es tener que andar actualizando Wordpress (cosa lógica y normal) y aunque ya las actualizaciones sean automáticas, pues me molesta.&lt;/p&gt;&lt;p&gt;Total, que a esto le sumamos que GitHub ofrece desde hace tiempo &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; que consiste en alojamiento gratuito para HTML estático y más a huevo imposible... quedaría pendiente el tema de los comentarios, pero precisamente para esto, &lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt; permite incluirlos por Javascript con una configuración muy sencilla.&lt;/p&gt;&lt;p&gt;Con esto ya va quedando claro el enfoque, ahora habría que ver como generar el HTML, ya que escribir HTML a pelo es posible, pero es más bien coñazo. GitHub Pages usa &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; que permite usar Markdown para escribir, pero como buen javero de pro he buscado una opción similar en Java, &lt;a href=&quot;http://jbake.org/&quot;&gt;JBake&lt;/a&gt;. Eso sí, el inconveniente es claro, con Jekyll lo único que hay que subir a GitHub son los archivos .md mientras que con JBake tendré que generar el HTML y subirlo.&lt;/p&gt;&lt;p&gt;Por tanto, hay tres trabajos importantes que hacer para estudiar la viabilidad de usar GitHub Pages para alojar el blog:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Integrar Disqus en JBake.&lt;/li&gt;
  &lt;li&gt;Personalizar el HTML generado por JBake.&lt;/li&gt;
  &lt;li&gt;Ver como subir los fuentes y HTML a GitHub y estudiar el workflow de publicación.&lt;/li&gt;
&lt;/ol&gt;
	</description>
    </item>

  </channel>
</rss>
